<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Earthquake Depth Map</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

    <style>
        body, html { margin: 0; padding: 0; height: 100%; background-color: black; font-family: sans-serif; overflow: hidden; }

        #controls-container {
            background-color: #1a1a1a;
            padding: 10px 20px;
            color: #eee;
            box-shadow: 0 4px 15px rgba(0,0,0,0.8);
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            border-bottom: 1px solid #333;
            z-index: 10;
            position: relative;
            flex-wrap: wrap;
        }

        h2 { margin: 0; font-size: 18px; color: cyan; margin-right: 10px; }

        .control-group { display: flex; flex-direction: column; width: 130px; }

        label { font-size: 11px; margin-bottom: 5px; color: #aaa; font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px;}
        span.val { color: white; float: right; }

        input[type=range] {
            width: 100%; cursor: pointer; accent-color: cyan;
            height: 4px; background: #444; border-radius: 2px;
        }

        select {
            background: #333; color: white; border: 1px solid #555;
            padding: 2px 5px; border-radius: 3px; width: 100%; font-size: 12px; cursor: pointer;
        }

        #chart-container { height: calc(100vh - 75px); width: 100%; }

        #info-overlay {
            position: absolute; bottom: 10px; left: 10px;
            color: rgba(255,255,255,0.6); font-size: 12px;
            pointer-events: none; user-select: none;
            z-index: 5;
        }

        #loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: cyan; font-size: 24px; font-weight: bold;
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; z-index: 1000;
        }
    </style>
</head>
<body>

    <div id="loading">Fetching USGS Data...</div>

    <div id="controls-container">
        <h2>Earthquake<br>Depth Map</h2>

        <div class="control-group" style="width: 100px;">
            <label>Palette</label>
            <select id="color-select">
                <option value="Hot" selected>Hot</option>
                <option value="YlGnBu">YlGnBu</option>
                <option value="Rainbow">Rainbow</option>
                <option value="YlOrRd">YlOrRd</option>
                <option value="Greys">Greys</option>
                <option value="Electric">Electric</option>
            </select>
        </div>

        <div class="control-group" style="width: 100px;">
            <label>Colour By</label>
            <select id="color-mode">
                <option value="mag" selected>Magnitude</option>
                <option value="depth">Depth</option>
                <option value="date">Date</option>
            </select>
        </div>

        <div class="control-group">
            <label>Point Size: <span id="size-val" class="val">2.5</span></label>
            <input type="range" id="size-slider" min="0.5" max="5.0" step="0.5">
        </div>

        <div class="control-group">
            <label>Mag Bonus: <span id="mag-val" class="val">0.1</span></label>
            <input type="range" id="mag-slider" min="0" max="1" step="0.01">
        </div>

        <div class="control-group">
            <label>Depth Scale: <span id="depth-val" class="val">2.5</span></label>
            <input type="range" id="depth-slider" min="1" max="5" step="0.1">
        </div>

        <div class="control-group" style="width: 80px;">
            <label>Borders: <span id="border-val" class="val">1</span></label>
            <input type="range" id="border-slider" min="0" max="4" step="1">
        </div>
    </div>

    <div id="chart-container"></div>
    <div id="info-overlay">Waiting for data...</div>

    <script>
        // --- Constants ---
        const EARTH_RADIUS = 6371;
        const USGS_URL = "https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.geojson";
        const BORDERS_URL = "https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json";

        // Exponential steps for borders
        const BORDER_WIDTHS = [0, 1, 2, 4, 8, 16];

        // --- ROTATION SETTINGS ---
        const ROTATION_SPEED = 0.001;

        // --- State ---
        let rawQuakeData = [];
        let stats = {
            maxMag: 0,
            maxDepth: 0,
            minTime: 0,
            maxTime: 0,
            avgMag: 0
        };

        let staticBorderArrays = { x: [], y: [], z: [] };
        let staticGridArrays = { x: [], y: [], z: [] };

        // Interaction State
        let autoRotate = true; // Rotates until user clicks/drags/zooms

        // --- Math Helpers ---
        function latLonToXYZ(lat, lon, radius) {
            const latRad = lat * Math.PI / 180;
            const lonRad = lon * Math.PI / 180;
            const x = radius * Math.cos(latRad) * Math.cos(lonRad);
            const y = radius * Math.cos(latRad) * Math.sin(lonRad);
            const z = radius * Math.sin(latRad);
            return [x, y, z];
        }

        // --- Data Generators ---
        function processBorders(geojson) {
            const bx = [], by = [], bz = [];
            geojson.features.forEach(feature => {
                const polygons = (feature.geometry.type === 'Polygon') ? feature.geometry.coordinates : feature.geometry.coordinates;
                polygons.forEach(poly => {
                    const actualPoly = (feature.geometry.type === 'MultiPolygon') ? poly[0] : poly;
                    actualPoly.forEach(pt => {
                        const [x, y, z] = latLonToXYZ(pt[1], pt[0], EARTH_RADIUS);
                        bx.push(x); by.push(y); bz.push(z);
                    });
                    bx.push(null); by.push(null); bz.push(null);
                });
            });
            return { x: bx, y: by, z: bz };
        }

        function generateWireframeGrid() {
            const gx = [], gy = [], gz = [];
            for (let lat = -90; lat <= 90; lat += 15) {
                for (let lon = -180; lon <= 180; lon += 5) {
                    const [x, y, z] = latLonToXYZ(lat, lon, EARTH_RADIUS);
                    gx.push(x); gy.push(y); gz.push(z);
                }
                gx.push(null); gy.push(null); gz.push(null);
            }
            for (let lon = -180; lon <= 180; lon += 30) {
                for (let lat = -90; lat <= 90; lat += 5) {
                    const [x, y, z] = latLonToXYZ(lat, lon, EARTH_RADIUS);
                    gx.push(x); gy.push(y); gz.push(z);
                }
                gx.push(null); gy.push(null); gz.push(null);
            }
            return { x: gx, y: gy, z: gz };
        }

        // --- Main App Logic ---
        async function initApp() {
            try {
                console.log("Starting application...");

                // Defaults
                document.getElementById('size-slider').value = "2.5";
                document.getElementById('mag-slider').value = "0.1";
                document.getElementById('depth-slider').value = "2.5";
                document.getElementById('border-slider').value = "1";
                document.getElementById('color-select').value = "Hot";
                document.getElementById('color-mode').value = "mag";
                updateLabels();

                // Fetch
                console.log("Downloading data...");
                const [quakeRes, borderRes] = await Promise.all([
                    fetch(USGS_URL),
                    fetch(BORDERS_URL)
                ]);

                const quakeJson = await quakeRes.json();
                const borderJson = await borderRes.json();

                staticBorderArrays = processBorders(borderJson);
                staticGridArrays = generateWireframeGrid();

                // Process Stats
                let minT = Infinity, maxT = -Infinity;
                let totalMag = 0, count = 0;
                let totalRealMag = 0;

                rawQuakeData = quakeJson.features.map(f => {
                    const realMag = f.properties.mag || 0;
                    const visualMag = Math.max(realMag, 0.1);
                    const depth = f.geometry.coordinates[2];
                    const time = f.properties.time;

                    if (visualMag > stats.maxMag) stats.maxMag = visualMag;
                    if (depth > stats.maxDepth) stats.maxDepth = depth;
                    if (time < minT) minT = time;
                    if (time > maxT) maxT = time;

                    totalMag += visualMag;
                    totalRealMag += realMag;
                    count++;

                    return {
                        lat: f.geometry.coordinates[1],
                        lon: f.geometry.coordinates[0],
                        depth: depth,
                        mag: visualMag,
                        realMag: realMag,
                        time: time,
                        place: f.properties.place || "Unknown"
                    };
                });

                stats.avgMag = count > 0 ? (totalMag / count) : 0;
                const realAvgMag = count > 0 ? (totalRealMag / count) : 0;
                stats.minTime = minT;
                stats.maxTime = maxT;

                // Console Log
                console.log("--- DATA REPORT ---");
                console.log(`Total Earthquakes: ${count}`);
                console.log(`Average Magnitude: ${realAvgMag.toFixed(3)}`);
                console.log("-------------------");

                document.getElementById('info-overlay').innerText =
                    `Data: ${count} earthquakes (30 Days). Source: USGS.`;
                document.getElementById('loading').style.display = 'none';

                // Listeners
                const inputs = ['size-slider', 'mag-slider', 'depth-slider', 'border-slider'];
                inputs.forEach(id => {
                    document.getElementById(id).addEventListener('input', () => { updateLabels(); updatePlot(); });
                });
                document.getElementById('color-select').addEventListener('change', () => updatePlot());
                document.getElementById('color-mode').addEventListener('change', () => updatePlot());

                // Initial Draw
                updatePlot(true);

                // --- INTERACTION LOGIC (Stop on Click/Touch/Zoom) ---
                const graphDiv = document.getElementById('chart-container');

                const stopRotation = () => {
                    autoRotate = false;
                };

                // Stop on Click/Drag
                graphDiv.addEventListener('mousedown', stopRotation);
                graphDiv.addEventListener('touchstart', stopRotation);
                // Stop on Zoom (Wheel) - Prevents snap back
                graphDiv.addEventListener('wheel', stopRotation);

                // Start Animation Loop
                requestAnimationFrame(animateGlobe);

            } catch (err) {
                console.error("Critical Error:", err);
                document.getElementById('loading').innerText = "Error loading data.";
            }
        }

        function animateGlobe() {
            if (autoRotate) {
                const graphDiv = document.getElementById('chart-container');

                // Get the LIVE camera from Plotly's internal layout
                const scene = graphDiv._fullLayout ? graphDiv._fullLayout.scene : null;

                if (scene && scene.camera) {
                    const eye = scene.camera.eye;

                    // Rotate Math (Around Z axis)
                    const cos = Math.cos(ROTATION_SPEED);
                    const sin = Math.sin(ROTATION_SPEED);

                    const newX = eye.x * cos - eye.y * sin;
                    const newY = eye.x * sin + eye.y * cos;

                    // Apply rotation. This respects current Z (zoom level) logic from previous frame.
                    Plotly.relayout('chart-container', {
                        'scene.camera.eye': { x: newX, y: newY, z: eye.z }
                    });
                }
            }
            requestAnimationFrame(animateGlobe);
        }

        function updateLabels() {
            document.getElementById('size-val').innerText = parseFloat(document.getElementById('size-slider').value).toFixed(1);
            document.getElementById('mag-val').innerText = parseFloat(document.getElementById('mag-slider').value).toFixed(2);
            document.getElementById('depth-val').innerText = parseFloat(document.getElementById('depth-slider').value).toFixed(1);

            const bIndex = parseInt(document.getElementById('border-slider').value);
            document.getElementById('border-val').innerText = BORDER_WIDTHS[bIndex];
        }

        function calculateResponsiveCamera() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const aspectRatio = width / height;

            // BASE DISTANCE (How close do you want it on a nice wide monitor?)
            // 0.9 = Very Close (Fills height)
            const baseDistance = 0.9;

            let finalDistance;

            if (aspectRatio >= 1) {
                // LANDSCAPE: Height is the constraint.
                // Distance is fixed because vertical FOV is usually fixed.
                finalDistance = baseDistance;
            } else {
                // PORTRAIT: Width is the constraint.
                // We need to pull back proportional to how skinny the screen is.
                // Formula: base / aspect_ratio
                finalDistance = baseDistance / aspectRatio;
            }

            return {
                eye: { x: finalDistance, y: finalDistance, z: finalDistance * 0.5 },
                center: { x: 0, y: 0, z: 0 }
            };
        }

        function updatePlot(isInitial = false) {
            const baseSize = parseFloat(document.getElementById('size-slider').value);
            const magBonusScale = parseFloat(document.getElementById('mag-slider').value);
            const depthScale = parseFloat(document.getElementById('depth-slider').value);
            const borderWidth = BORDER_WIDTHS[parseInt(document.getElementById('border-slider').value)];

            const selectedPalette = document.getElementById('color-select').value;
            const colorMode = document.getElementById('color-mode').value;

            const qx = [], qy = [], qz = [], sizes = [], ghostSizes = [], colors = [], texts = [];
            const MIDPOINT = stats.avgMag;

            for (const q of rawQuakeData) {
                const r_quake = EARTH_RADIUS - (q.depth * depthScale);
                const [x, y, z] = latLonToXYZ(q.lat, q.lon, r_quake);
                qx.push(x); qy.push(y); qz.push(z);

                let sizeFactor = q.mag;
                if (q.mag > MIDPOINT) {
                    const diff = q.mag - MIDPOINT;
                    sizeFactor += (Math.pow(diff, 3) * magBonusScale);
                }
                const s = baseSize * (sizeFactor / 2.5);
                sizes.push(s);
                ghostSizes.push(Math.max(s, 10));

                if (colorMode === 'depth') colors.push(q.depth);
                else if (colorMode === 'mag') colors.push(q.mag);
                else colors.push(q.time);

                const dateStr = new Date(q.time).toLocaleDateString();
                texts.push(
                    `<b>${q.place}</b><br>` +
                    `Date: ${dateStr}<br>` +
                    `Magnitude: ${q.realMag.toFixed(2)}<br>` +
                    `Depth: ${q.depth.toFixed(2)}km`
                );
            }

            let colorSettings = {
                colorscale: selectedPalette,
                colorbar: { x: 0, len: 0.5, thickness: 15, titlefont: {color: 'white'}, tickfont: {color: 'white'} }
            };

            if (colorMode === 'depth') {
                colorSettings.title = 'Depth (km)';
                colorSettings.cmin = 0;
                colorSettings.cmax = Math.ceil(stats.maxDepth / 100) * 100;
            } else if (colorMode === 'mag') {
                colorSettings.title = 'Magnitude';
                colorSettings.cmin = 0;
                colorSettings.cmax = 9;
            } else {
                colorSettings.title = 'Date';
                colorSettings.cmin = stats.minTime;
                colorSettings.cmax = stats.maxTime;
            }

            const gridTrace = {
                type: 'scatter3d', mode: 'lines',
                x: staticGridArrays.x, y: staticGridArrays.y, z: staticGridArrays.z,
                line: { color: '#333', width: 1 }, opacity: 0.5, hoverinfo: 'skip'
            };

            const borderTrace = {
                type: 'scatter3d', mode: 'lines',
                x: staticBorderArrays.x, y: staticBorderArrays.y, z: staticBorderArrays.z,
                line: { color: '#00ffff', width: borderWidth }, opacity: 0.4, hoverinfo: 'skip',
                visible: borderWidth > 0
            };

            const quakeTrace = {
                type: 'scatter3d', mode: 'markers',
                x: qx, y: qy, z: qz,
                hoverinfo: 'skip',
                marker: {
                    size: sizes, color: colors,
                    colorscale: colorSettings.colorscale, cmin: colorSettings.cmin, cmax: colorSettings.cmax,
                    colorbar: colorSettings.colorbar, opacity: 1.0, line: { width: 0 }
                }
            };

            const ghostTrace = {
                type: 'scatter3d', mode: 'markers',
                x: qx, y: qy, z: qz,
                text: texts, hoverinfo: 'text',
                marker: { size: ghostSizes, color: 'rgba(0,0,0,0)', opacity: 0.0 }
            };

            const layout = {
                paper_bgcolor: 'black', plot_bgcolor: 'black',
                margin: { l: 0, r: 0, t: 0, b: 0 },
                hovermode: 'closest',
                scene: {
                    xaxis: { visible: false, showbackground: false },
                    yaxis: { visible: false, showbackground: false },
                    zaxis: { visible: false, showbackground: false },
                    aspectmode: 'data',
                    dragmode: 'orbit'
                },
                showlegend: false
            };

            // Calculate Responsive Zoom
            if(isInitial) {
                layout.scene.camera = calculateResponsiveCamera();
            }

            // Using uirevision to prevent resets on data updates
            layout.uirevision = 'true';

            Plotly.react('chart-container', [gridTrace, borderTrace, quakeTrace, ghostTrace], layout, {responsive: true});
        }

        initApp();
    </script>
</body>
</html>
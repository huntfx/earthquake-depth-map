<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Earthquake Depth Map</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

    <style>
        body, html { margin: 0; padding: 0; height: 100%; background-color: black; font-family: sans-serif; overflow: hidden; transition: background-color 0.3s; }

        /* DARK MODE (DEFAULT) */
        #menu-btn {
            position: absolute; top: 15px; left: 15px;
            background: rgba(0, 0, 0, 0.6);
            color: cyan;
            border: 1px solid cyan;
            border-radius: 4px;
            font-size: 20px;
            padding: 0 12px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.2s;
            box-sizing: border-box;
        }
        #menu-btn:hover { background: rgba(0, 255, 255, 0.2); }

        /* THEME TOGGLE BUTTON */
        #theme-btn {
            position: absolute; top: 15px; right: 15px;
            background: rgba(0, 0, 0, 0.6);
            color: cyan;
            border: 1px solid cyan;
            border-radius: 4px;
            font-size: 20px;
            padding: 0;
            height: 40px;
            width: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.2s;
            line-height: 1;
            box-sizing: border-box;
        }
        #theme-btn:hover { background: rgba(0, 255, 255, 0.2); }

        /* ROTATION TOGGLE BUTTON */
        #rotate-btn {
            position: absolute; top: 15px; right: 65px;
            background: rgba(0, 0, 0, 0.6);
            color: cyan;
            border: 1px solid cyan;
            border-radius: 4px;
            font-size: 18px;
            padding: 0;
            height: 40px;
            width: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.2s;
            line-height: 1;
            box-sizing: border-box;
        }
        #rotate-btn:hover { background: rgba(0, 255, 255, 0.2); }

        /* RESET VIEW BUTTON */
        #reset-btn {
            position: absolute; top: 15px; right: 115px;
            background: rgba(0, 0, 0, 0.6);
            color: cyan;
            border: 1px solid cyan;
            border-radius: 4px;
            font-size: 20px;
            padding: 0;
            height: 40px;
            width: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.2s;
            line-height: 1;
            box-sizing: border-box;
        }
        #reset-btn:hover { background: rgba(0, 255, 255, 0.2); }

        /* GPS BUTTON */
        #gps-btn {
            position: absolute; top: 15px; right: 165px;
            background: rgba(0, 0, 0, 0.6);
            color: cyan;
            border: 1px solid cyan;
            border-radius: 4px;
            padding: 0;
            height: 40px;
            width: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.2s;
            box-sizing: border-box;
        }
        #gps-btn svg {
            width: 20px;
            height: 20px;
            stroke: cyan;
            fill: none;
            stroke-width: 2;
        }
        #gps-btn circle.inner {
            fill: cyan;
            stroke: none;
        }
        #gps-btn:hover { background: rgba(0, 255, 255, 0.2); }

        /* TIMELAPSE BUTTON (MOVED TO HEADER) */
        #timelapse-mode-btn {
            position: absolute; top: 15px; right: 215px; /* Left of GPS (165 + 50) */
            background: rgba(0, 0, 0, 0.6);
            color: cyan;
            border: 1px solid cyan;
            border-radius: 4px;
            font-size: 20px;
            padding: 0;
            height: 40px;
            width: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.2s;
            line-height: 1;
            box-sizing: border-box;
        }
        #timelapse-mode-btn:hover { background: rgba(0, 255, 255, 0.2); }

        #side-panel {
            position: fixed;
            top: 0; left: -340px;
            width: 300px;
            height: 100%;
            background: rgba(20, 20, 20, 0.95);
            border-right: 1px solid #333;
            box-shadow: 2px 0 15px rgba(0,0,0,0.8);
            z-index: 1002;
            transition: left 0.3s cubic-bezier(0.4, 0.0, 0.2, 1), background-color 0.3s;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
        }

        #side-panel.open { left: 0; }

        #close-btn {
            position: absolute; top: 15px; right: 15px;
            background: none; border: none; color: #666;
            font-size: 24px; cursor: pointer;
        }
        #close-btn:hover { color: white; }

        h2 { margin: 0 0 20px 0; font-size: 22px; color: cyan; border-bottom: 1px solid #333; padding-bottom: 15px; }
        h3 { margin: 20px 0 10px 0; font-size: 14px; color: #888; text-transform: uppercase; border-bottom: 1px solid #444; padding-bottom: 5px; }
        h3:first-of-type { margin-top: 0; }

        .control-group { margin-bottom: 15px; width: 100%; }

        label { display: block; font-size: 12px; margin-bottom: 5px; color: #aaa; font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px;}
        span.val { color: white; float: right; }

        input[type=range] {
            width: 100%; cursor: pointer; accent-color: cyan;
            height: 4px; background: #444; border-radius: 2px;
        }

        input[type=date], input[type=text], input[type=number] {
            width: 100%; background: #333; color: white; border: 1px solid #555;
            padding: 5px; border-radius: 3px; font-family: sans-serif;
            box-sizing: border-box;
        }

        /* Search Box Specifics */
        .search-container { display: flex; gap: 5px; }
        .search-btn {
            background: #444; color: cyan; border: 1px solid #555; cursor: pointer;
            padding: 5px 10px; border-radius: 3px; font-weight: bold; text-transform: uppercase;
            font-size: 11px; transition: all 0.2s;
        }
        .search-btn:hover { background: #555; border-color: cyan; }
        .search-btn:disabled {
            opacity: 0.5; cursor: not-allowed; background: #333; color: #888; border-color: #555;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #333;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #555;
            margin-bottom: 15px;
        }
        .checkbox-group label { margin: 0; cursor: pointer; color: white; }
        input[type=checkbox] { width: 16px; height: 16px; cursor: pointer; accent-color: cyan; }

        .preset-group { display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 15px; }
        .preset-btn {
            flex: 1 1 30%; background: #333; color: #ddd; border: 1px solid #555;
            padding: 8px 5px; font-size: 11px; cursor: pointer; border-radius: 3px;
            transition: all 0.2s; text-transform: uppercase; font-weight: bold;
            white-space: nowrap;
        }
        .preset-btn:hover { background: #444; border-color: cyan; color: cyan; }

        select {
            background: #333; color: white; border: 1px solid #555;
            padding: 8px; border-radius: 3px; width: 100%; font-size: 13px; cursor: pointer;
        }

        #load-btn, #render-btn {
            width: 100%; background: cyan; color: black; border: none;
            padding: 10px; font-weight: bold; cursor: pointer;
            margin-bottom: 20px; border-radius: 4px;
            text-transform: uppercase; letter-spacing: 1px;
            transition: background 0.2s;
        }
        #load-btn:hover, #render-btn:hover { background: #ccffff; }

        #chart-container { height: 100vh; width: 100%; }

        #info-overlay {
            position: absolute; bottom: 15px; left: 15px;
            color: rgba(255,255,255,0.5); font-size: 11px;
            pointer-events: none; user-select: none;
            z-index: 5;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 4px;
            transition: color 0.3s;
        }

        #loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: cyan; font-size: 24px; font-weight: bold;
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; z-index: 2000;
        }

        /* POPUP STYLES */
        #quake-info {
            position: absolute; top: 60px; right: 15px;
            width: 250px;
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid cyan;
            border-radius: 4px;
            padding: 15px;
            color: white;
            display: none;
            z-index: 1005;
            box-shadow: 0 0 15px rgba(0,0,0,0.8);
            font-family: sans-serif;
            animation: fadeIn 0.2s ease-out;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }

        #quake-info h3 {
            margin: 0 0 10px 0; color: cyan; font-size: 15px; border-bottom: 1px solid #444; padding-bottom: 5px;
            line-height: 1.3;
        }
        #quake-info p { margin: 6px 0; font-size: 13px; color: #ccc; }
        #quake-info strong { color: white; }
        #quake-info a {
            display: block; margin-top: 12px; color: black; background: cyan;
            text-align: center; padding: 8px; text-decoration: none;
            border-radius: 3px; font-weight: bold; font-size: 12px; transition: background 0.2s;
        }
        #quake-info a:hover { background: #ccffff; }
        #quake-info-close {
            position: absolute; top: 5px; right: 10px; cursor: pointer; color: #666; font-size: 18px; font-weight: bold;
        }
        #quake-info-close:hover { color: white; }

        /* SIMULATE BUTTON */
        #qi-sim-btn {
            display: block; width: 100%; margin-top: 8px;
            background: transparent; color: cyan;
            border: 1px solid cyan; border-radius: 3px;
            padding: 8px; text-transform: uppercase; font-weight: bold; font-size: 11px;
            cursor: pointer; transition: all 0.2s;
        }
        #qi-sim-btn:hover { background: rgba(0, 255, 255, 0.1); }

        /* --- TIME LAPSE CONTROLS --- */
        #timelapse-bar {
            position: fixed;
            bottom: 30px; left: 50%;
            transform: translateX(-50%);
            width: 90%; max-width: 600px;
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid cyan;
            border-radius: 8px;
            padding: 15px;
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 10px;
            z-index: 1004;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        #timelapse-bar.active { display: flex; }

        .tl-row { display: flex; justify-content: space-between; align-items: center; gap: 10px; }

        #tl-date-display {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            color: cyan;
            min-width: 180px;
            text-align: center;
        }

        #tl-play-btn {
            background: none; border: 1px solid cyan; color: cyan;
            width: 40px; height: 30px; cursor: pointer; border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            font-size: 16px;
        }
        #tl-play-btn:hover { background: rgba(0, 255, 255, 0.2); }

        #tl-close-btn {
            background: none; border: none; color: #666; cursor: pointer; font-size: 18px;
        }
        #tl-close-btn:hover { color: white; }

        #tl-scrubber { width: 100%; accent-color: cyan; cursor: pointer; }

        .tl-select {
            background: #333; color: white; border: 1px solid #555;
            padding: 4px; border-radius: 3px; font-size: 11px;
        }


        /* --- LIGHT MODE OVERRIDES --- */
        body.light-mode {
            background-color: #f0f0f0; /* Off-white background */
            color: #333; /* Dark grey text */
        }
        body.light-mode #side-panel {
            background: rgba(255, 255, 255, 0.95); /* Translucent white panel */
            border-right: 1px solid #ccc;
            box-shadow: 2px 0 15px rgba(0,0,0,0.1);
        }
        body.light-mode #menu-btn {
            background: rgba(255, 255, 255, 0.9);
            color: #008080; /* Teal accent */
            border-color: #008080;
        }
        body.light-mode #menu-btn:hover {
            background: rgba(0, 128, 128, 0.1);
        }
        body.light-mode #theme-btn, body.light-mode #rotate-btn, body.light-mode #reset-btn, body.light-mode #gps-btn, body.light-mode #timelapse-mode-btn {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border-color: #333;
        }
        body.light-mode #theme-btn:hover, body.light-mode #rotate-btn:hover, body.light-mode #reset-btn:hover, body.light-mode #gps-btn:hover, body.light-mode #timelapse-mode-btn:hover {
            background: rgba(0, 0, 0, 0.05);
        }
        body.light-mode #gps-btn svg {
            stroke: #333;
        }
        body.light-mode #gps-btn circle.inner {
            fill: #333;
        }

        body.light-mode h2 {
            color: #008080; /* Teal accent */
            border-bottom-color: #ccc;
        }
        body.light-mode h3 {
            color: #666;
            border-bottom-color: #ddd;
        }
        body.light-mode label {
            color: #555;
        }
        body.light-mode span.val {
            color: #333;
        }
        body.light-mode input[type=date],
        body.light-mode input[type=text],
        body.light-mode input[type=number],
        body.light-mode select,
        body.light-mode .tl-select {
            background: white;
            color: #333;
            border-color: #bbb;
        }
        body.light-mode .checkbox-group {
            background: white;
            border-color: #bbb;
        }
        body.light-mode .checkbox-group label {
            color: #333;
        }
        body.light-mode .preset-btn {
            background: white;
            color: #333;
            border-color: #bbb;
        }
        body.light-mode .preset-btn:hover {
            background: #e6f2f2;
            border-color: #008080;
            color: #008080;
        }
        body.light-mode input[type=range] {
            background: #ddd;
            accent-color: #008080; /* Teal accent */
        }
        body.light-mode #load-btn, body.light-mode #render-btn {
            background: #008080; /* Teal accent */
            color: white;
        }
        body.light-mode #load-btn:hover, body.light-mode #render-btn:hover {
            background: #006666; /* Darker teal on hover */
        }
        body.light-mode .search-btn {
            background: #f0f0f0;
            color: #008080;
            border-color: #ccc;
        }
        body.light-mode .search-btn:hover {
            background: #e0e0e0;
        }
        body.light-mode .search-btn:disabled {
            background: #eee; color: #aaa; border-color: #ddd; cursor: not-allowed;
        }
        body.light-mode #info-overlay {
            background: rgba(255, 255, 255, 0.85);
            color: #333;
            border: 1px solid #ddd;
        }

        /* Popup Light Mode */
        body.light-mode #quake-info {
            background: rgba(255, 255, 255, 0.95);
            border-color: #008080;
            color: #333;
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
        }
        body.light-mode #quake-info h3 {
            color: #008080;
            border-bottom-color: #eee;
        }
        body.light-mode #quake-info p {
            color: #555;
        }
        body.light-mode #quake-info strong {
            color: #333;
        }
        body.light-mode #quake-info a {
            background: #008080;
            color: white;
        }
        body.light-mode #quake-info a:hover {
            background: #006666;
        }
        body.light-mode #close-btn:hover {
            color: #333;
        }
        body.light-mode #qi-sim-btn {
            color: #008080; border-color: #008080;
        }
        body.light-mode #qi-sim-btn:hover {
            background: rgba(0, 128, 128, 0.1);
        }
        /* Loading Overlay Light Mode */
        body.light-mode #loading {
            background: rgba(255, 255, 255, 0.95);
            color: #008080;
            border: 1px solid #008080;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
        }

        /* Time Lapse Light Mode */
        body.light-mode #timelapse-bar {
            background: rgba(255, 255, 255, 0.9);
            border-color: #008080;
            color: #333;
        }
        body.light-mode #tl-date-display, body.light-mode #tl-play-btn {
            color: #008080;
        }
        body.light-mode #tl-play-btn { border-color: #008080; }
        body.light-mode #tl-play-btn:hover { background: rgba(0, 128, 128, 0.1); }
    </style>
</head>
<body>

    <div id="loading">Initializing...</div>

    <!-- BUTTONS -->
    <button id="timelapse-mode-btn">⏱</button>
    <button id="gps-btn">
        <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="10"></circle>
            <circle cx="12" cy="12" r="4" class="inner"></circle>
        </svg>
    </button>
    <button id="reset-btn">⟳</button>
    <button id="rotate-btn">❚❚</button>
    <button id="theme-btn">☀</button>

    <!-- POPUP -->
    <div id="quake-info">
        <div id="quake-info-close" onclick="document.getElementById('quake-info').style.display='none'">×</div>
        <h3 id="qi-place">Location</h3>
        <!-- The content inside these p tags is dynamically updated -->
        <p><strong id="qi-label-1">Magnitude:</strong> <span id="qi-val-1"></span></p>
        <p><strong id="qi-label-2">Depth:</strong> <span id="qi-val-2"></span></p>
        <p><strong id="qi-label-3">Time:</strong> <span id="qi-val-3"></span></p>
        <button id="qi-sim-btn">Simulate Wave</button>
        <a href="#" target="_blank" id="qi-link">View on USGS ↗</a>
    </div>

    <!-- TIMELAPSE CONTROLS (Hidden by default) -->
    <div id="timelapse-bar">
        <div class="tl-row">
            <button id="tl-play-btn">▶</button>
            <div id="tl-date-display">----/--/-- --:--</div>
            <select id="tl-speed" class="tl-select">
                <option value="3600000">1 Hr / sec</option>
                <option value="10800000">3 Hrs / sec</option>
                <option value="21600000">6 Hrs / sec</option>
                <option value="43200000">12 Hrs / sec</option>
                <option value="86400000" selected>1 Day / sec</option>
                <option value="172800000">2 Days / sec</option>
                <option value="345600000">4 Days / sec</option>
                <option value="604800000">1 Week / sec</option>
            </select>
            <button id="tl-close-btn">×</button>
        </div>
        <div class="tl-row">
            <input type="range" id="tl-scrubber" min="0" max="100" value="0">
        </div>
        <div class="tl-row" style="font-size: 11px; color: #888; justify-content: flex-start;">
             <label style="display:inline; margin-right:5px; margin-bottom:0;">Trail:</label>
             <select id="tl-window" class="tl-select" style="width: auto;">
                <option value="86400000">1 Day</option>
                <option value="172800000">2 Days</option>
                <option value="345600000" selected>4 Days</option>
                <option value="604800000">1 Week</option>
             </select>

             <!-- POP TOGGLE -->
             <div style="margin-left: 15px; display: flex; align-items: center;">
                <input type="checkbox" id="tl-pop-check" checked style="width: 14px; height: 14px; margin-right: 5px; accent-color: cyan;">
                <label for="tl-pop-check" style="margin:0; cursor:pointer;">Pop In Animation</label>
             </div>

             <!-- SOUND TOGGLE -->
             <div style="margin-left: 15px; display: flex; align-items: center;">
                <input type="checkbox" id="tl-sound-check" style="width: 14px; height: 14px; margin-right: 5px; accent-color: cyan;">
                <label for="tl-sound-check" style="margin:0; cursor:pointer;">Sound</label>
             </div>
        </div>
    </div>

    <button id="menu-btn">☰ Settings</button>

    <div id="side-panel">
        <button id="close-btn">×</button>
        <h2>Earthquake<br>Depth Map</h2>

        <!-- Search Feature -->
        <div class="control-group">
            <label>Search Country</label>
            <div class="search-container">
                <input type="text" id="search-input" placeholder="e.g. Japan, Chile" list="locations-list">
                <datalist id="locations-list"></datalist>
                <button id="search-btn" class="search-btn" disabled>Go</button>
            </div>
        </div>

        <!-- Search Volcanoes -->
        <div class="control-group">
            <label>Search Volcano</label>
            <div class="search-container">
                <input type="text" id="volc-search-input" placeholder="e.g. Fuji, Etna" list="volcanoes-list">
                <datalist id="volcanoes-list"></datalist>
                <button id="volc-search-btn" class="search-btn" disabled>Go</button>
            </div>
        </div>

        <!-- Seismic Zones -->
        <div class="control-group">
            <label>Seismic Zones</label>
            <div class="search-container">
                <input type="text" id="zone-input" placeholder="Select Zone..." list="zones-list">
                <datalist id="zones-list"></datalist>
                <button id="zone-btn" class="search-btn" disabled>Go</button>
            </div>
        </div>

        <h3>Presets</h3>
        <div class="preset-group">
            <button class="preset-btn" onclick="applyPreset('24h')">Last 24h</button>
            <button class="preset-btn" onclick="applyPreset('7d')">Last 7d</button>
            <button class="preset-btn" onclick="applyPreset('30d')">Last 30d</button>
            <button class="preset-btn" onclick="applyPreset('sig')">Major (>5)</button>
            <button class="preset-btn" onclick="applyPreset('deep')">Deep (>300km)</button>
        </div>

        <h3>Data Filters</h3>

        <div class="control-group">
            <label>Start Date</label>
            <input type="date" id="start-date">
        </div>
        <div class="control-group">
            <label>End Date</label>
            <input type="date" id="end-date">
        </div>

        <div class="control-group">
            <label>Min Magnitude: <span id="min-mag-val" class="val">0.0</span></label>
            <input type="range" id="min-mag-slider" min="0" max="9" step="0.1" value="0">
        </div>
        <div class="control-group">
            <label>Max Magnitude: <span id="max-mag-val" class="val">10.0</span></label>
            <input type="range" id="max-mag-slider" min="0" max="10" step="0.1" value="10">
        </div>

        <div class="control-group">
            <label>Min Depth (km): <span id="min-depth-filter-val" class="val">0</span></label>
            <input type="range" id="min-depth-filter" min="0" max="800" step="10" value="0">
        </div>
        <div class="control-group">
            <label>Max Depth (km): <span id="max-depth-filter-val" class="val">800</span></label>
            <input type="range" id="max-depth-filter" min="0" max="800" step="10" value="800">
        </div>

        <div class="control-group">
            <label>Max Results</label>
            <select id="limit-select">
                <option value="1000">1,000</option>
                <option value="5000">5,000</option>
                <option value="10000" selected>10,000</option>
                <option value="20000">20,000</option>
            </select>
        </div>

        <button id="load-btn">Load Data</button>

        <h3>Visualization</h3>

        <div class="control-group">
            <label>Palette</label>
            <select id="color-select">
                <option value="Hot" selected>Hot</option>
                <option value="YlGnBu">YlGnBu</option>
                <option value="Rainbow">Rainbow</option>
                <option value="YlOrRd">YlOrRd</option>
                <option value="Greys">Greys</option>
                <option value="Electric">Electric</option>
            </select>
        </div>

        <div class="control-group">
            <label>Colour By</label>
            <select id="color-mode">
                <option value="mag" selected>Magnitude</option>
                <option value="depth">Depth</option>
                <option value="date">Date</option>
            </select>
        </div>

        <div class="control-group">
            <label>Point Size: <span id="size-val" class="val">2.5</span></label>
            <input type="range" id="size-slider" min="0.5" max="5.0" step="0.5">
        </div>

        <div class="control-group">
            <label>Magnitude Bonus: <span id="mag-val" class="val">0.1</span></label>
            <input type="range" id="mag-slider" min="0" max="1" step="0.01">
        </div>

        <div class="control-group">
            <label>Depth Scale: <span id="depth-val" class="val">2.5</span></label>
            <input type="range" id="depth-slider" min="1" max="5" step="0.5">
        </div>

        <div class="checkbox-group">
            <label for="borders-checkbox">Country Borders</label>
            <input type="checkbox" id="borders-checkbox" checked>
        </div>

        <div class="checkbox-group">
            <label for="labels-checkbox">Country Names</label>
            <input type="checkbox" id="labels-checkbox">
        </div>

        <div class="checkbox-group">
            <label for="plates-checkbox">Tectonic Plates</label>
            <input type="checkbox" id="plates-checkbox" checked>
        </div>

        <div class="checkbox-group">
            <label for="volcanoes-checkbox">Volcanoes</label>
            <input type="checkbox" id="volcanoes-checkbox">
        </div>

        <div class="checkbox-group">
            <label for="surface-lines-checkbox">Surface Lines</label>
            <input type="checkbox" id="surface-lines-checkbox">
        </div>
        <h3>Render Frames</h3>

        <div id="resume-container" style="display:none; margin-bottom: 15px; padding: 10px; background: #331111; border: 1px solid #ff4444; border-radius: 4px;">
            <div style="color: #ff8888; font-size: 11px; margin-bottom: 5px; font-weight: bold;">CRASH DETECTED</div>
            <div style="color: #ddd; font-size: 11px; margin-bottom: 8px;" id="resume-text">
                Incomplete render found (Frame 594 of 1024).
            </div>
            <button id="resume-btn" style="width: 100%; background: #ff4444; color: white; border: none; padding: 8px; border-radius: 3px; cursor: pointer; font-weight: bold; text-transform: uppercase;">
                Resume Previous Render
            </button>
        </div>

        <div class="control-group">
            <label>Filename & Format</label>
            <div style="display:flex; gap:5px;">
                <input type="text" id="filename-pattern" value="frame_####" style="flex:2;">
                <select id="render-format" style="flex:1;">
                    <option value="png" selected>.png</option>
                    <option value="jpeg">.jpg</option>
                    <option value="webp">.webp</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <label>Frame Count</label>
            <div style="display:flex; gap:10px; align-items: center;">
                <input type="range" id="frame-slider" min="1" max="1024" step="1" value="250" style="flex:2">
                <input type="number" id="frame-number" value="360" min="1" style="width: 70px; flex:1; text-align:right;">
            </div>
        </div>

        <div class="control-group">
            <label>Resolution Scale: <span id="render-scale-val" class="val">1x</span></label>
            <input type="range" id="render-scale" min="1" max="4" step="0.5" value="1">
        </div>

        <button id="render-btn">Start New Render</button>

    </div>

    <div id="chart-container"></div>
    <div id="info-overlay">Waiting for data...</div>

    <script>
        // --- Constants ---
        const EARTH_RADIUS = 6371;
        const USGS_BASE_URL = "https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&orderby=magnitude";
        const BORDERS_URL = "https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json";
        const PLATES_URL = "https://raw.githubusercontent.com/fraxen/tectonicplates/master/GeoJSON/PB2002_boundaries.json";
        const VOLCANOES_URL = "https://raw.githubusercontent.com/plotly/datasets/master/volcano_db.csv";
        const RENDER_SESSION_KEY = 'quake_render_session';

        // --- Configuration Constants ---
        // These are the single source of truth for widths. Change them here to update everywhere.
        const BASE_BORDER_WIDTH = 3;
        const BASE_PLATE_WIDTH = 4;

        const ROTATION_SPEED = -0.001;

        // --- State ---
        let rawQuakeData = [];
        let rawVolcanoData = [];
        let stats = { maxMag: 0, maxDepth: 0, minTime: 0, maxTime: 0, avgMag: 0 };

        let pulseState = null; // Stores pulse animation state
        let selectedQuake = null; // Current selected object for simulation

        let staticBorderArrays = { x: [], y: [], z: [] };
        let staticLabelArrays = { x: [], y: [], z: [], text: [] };
        let staticPlateArrays = { x: [], y: [], z: [] };
        let staticGridArrays = { x: [], y: [], z: [] };

        // Seismic Bookmarks Config - Display Names
        const seismicBookmarks = {
            "Ring of Fire (Pacific)": { lat: 0, lon: 180, zoom: 2.2 },
            "Japan Trench": { lat: 36, lon: 138, zoom: 1.2 },
            "Indonesia / Philippines": { lat: 5, lon: 120, zoom: 1.3 },
            "San Andreas Fault": { lat: 35, lon: -120, zoom: 1.2 },
            "Andes (South America)": { lat: -20, lon: -70, zoom: 1.2 },
            "Himalayas (Collision Zone)": { lat: 30, lon: 85, zoom: 1.2 },
            "Mid-Atlantic Ridge": { lat: 0, lon: -30, zoom: 1.8 }
        };

        // Single Source of Truth for Camera
        let currentCamera = {
            eye: {x: 1.5, y: 1.5, z: 1.5},
            center: {x: 0, y: 0, z: 0},
            up: {x: 0, y: 0, z: 1}
        };

        let autoRotate = true;
        let isLightMode = false;
        let rotationTimeout = null;

        // --- Time Lapse State ---
        let tlState = {
            active: false,
            playing: false,
            currentTime: 0,
            startTime: 0,
            endTime: 0,
            speed: 86400000, // ms per tick (default 1 day)
            windowSize: 345600000, // ms (default 4 days)
            popEnabled: true, // Default to true
            soundEnabled: false,
            lastSoundTime: 0,
            sortedData: [],
            lastDrawTime: 0,
            drawInterval: 25, // ms (10 FPS limit for visual chart updates)
            animationFrameId: null
        };

        const RenderSession = {
            start: (totalFrames) => {
                const state = {
                    status: 'active',
                    timestamp: Date.now(),
                    progress: { current: -1, total: totalFrames },
                    camera: currentCamera,
                    settings: {
                        // UI State
                        isLightMode: isLightMode,
                        frameValue: document.getElementById('frame-number').value,
                        startDate: document.getElementById('start-date').value,
                        endDate: document.getElementById('end-date').value,
                        minMag: document.getElementById('min-mag-slider').value,
                        maxMag: document.getElementById('max-mag-slider').value,
                        minDepth: document.getElementById('min-depth-filter').value,
                        maxDepth: document.getElementById('max-depth-filter').value,
                        limit: document.getElementById('limit-select').value,
                        colorSelect: document.getElementById('color-select').value,
                        colorMode: document.getElementById('color-mode').value,
                        size: document.getElementById('size-slider').value,
                        magBonus: document.getElementById('mag-slider').value,
                        depthScale: document.getElementById('depth-slider').value,
                        filename: document.getElementById('filename-pattern').value,
                        format: document.getElementById('render-format').value,
                        scale: document.getElementById('render-scale').value,
                        borders: document.getElementById('borders-checkbox').checked,
                        plates: document.getElementById('plates-checkbox').checked,
                        labels: document.getElementById('labels-checkbox').checked,
                        volcanoes: document.getElementById('volcanoes-checkbox').checked,
                        surfaceLines: document.getElementById('surface-lines-checkbox').checked
                    }
                };
                localStorage.setItem(RENDER_SESSION_KEY, JSON.stringify(state));
            },

            update: (frameIndex) => {
                const raw = localStorage.getItem(RENDER_SESSION_KEY);
                if (raw) {
                    const state = JSON.parse(raw);
                    state.progress.current = frameIndex;
                    localStorage.setItem(RENDER_SESSION_KEY, JSON.stringify(state));
                }
            },

            complete: () => {
                localStorage.removeItem(RENDER_SESSION_KEY);
                document.getElementById('resume-container').style.display = 'none';
            },

            check: () => {
                const raw = localStorage.getItem(RENDER_SESSION_KEY);
                if (!raw) return null;
                const state = JSON.parse(raw);
                if (state.status === 'active' && state.progress.current < state.progress.total - 1) {
                    return state;
                }
                return null;
            }
        };

        // --- Audio Context ---
        let audioCtx;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function snapToScale(freq) {
            // Convert frequency to nearest MIDI note
            const baseFreq = 440;
            // Calculate semitones from A4
            const semitones = 12 * Math.log2(freq / baseFreq);
            let midi = Math.round(semitones) + 69;

            // C Major Pentatonic: C, D, E, G, A
            // Relative to C (0): 0, 2, 4, 7, 9
            // MIDI 60 is C4. 60 % 12 = 0.
            const allowedPitchClasses = [0, 2, 4, 7, 9];

            // Find closest valid note by checking neighbors
            // We check current note, then +1/-1, +2/-2, etc.
            let bestMidi = midi;
            let found = false;

            for (let offset = 0; offset < 6; offset++) {
                // Check +offset
                let m1 = midi + offset;
                if (allowedPitchClasses.includes((m1 % 12 + 12) % 12)) {
                    bestMidi = m1;
                    found = true;
                    break;
                }
                // Check -offset
                if (offset > 0) {
                    let m2 = midi - offset;
                    if (allowedPitchClasses.includes((m2 % 12 + 12) % 12)) {
                        bestMidi = m2;
                        found = true;
                        break;
                    }
                }
            }

            // Convert back to frequency
            return baseFreq * Math.pow(2, (bestMidi - 69) / 12);
        }

        function playQuakeSound(q, delay = 0) {
            if (!audioCtx) return;

            // Safety: Clamp magnitude (handle negative or non-finite values)
            const safeMag = Math.max(0, Number.isFinite(q.realMag) ? q.realMag : 0);

            // Safety: Ensure delay is finite
            if (!Number.isFinite(delay)) delay = 0;

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const panner = audioCtx.createStereoPanner();

            // Frequency Calculation (Pitch)
            // 1. Small/Medium (< 5.0): Higher base (800Hz) for glassy pings.
            // 2. Large (>= 5.0): Start lower (300Hz) and drop heavily with magnitude (Bass).
            let freq;
            if (safeMag < 5.0) {
                // Small: High, clear tone
                // Base 800Hz, drops slightly with depth
                freq = 800 - (q.depth * 0.5);
                osc.type = 'sine';
            } else {
                // Large: Low, heavy rumble
                // Base 300Hz, drop 80Hz per magnitude above 5.0
                // Mag 6: 220Hz
                // Mag 7: 140Hz
                // Mag 8: 60Hz
                // Mag 9: ~30Hz
                freq = 300 - ((safeMag - 5.0) * 80) - (q.depth * 0.1);
                // Use Sawtooth/Square for grit
                osc.type = safeMag >= 7.5 ? 'square' : 'sawtooth';
            }

            // Safety Cap: Minimum 30Hz to avoid sub-sonic issues, snap to scale
            freq = Math.max(20, freq);
            freq = snapToScale(freq);
            osc.frequency.value = freq;

            // Volume: Exponential curve (Power 3)
            // Mag 3 ~ very quiet, Mag 8 ~ loud
            // Increased floor slightly for small quakes (0.02 base)
            const vol = Math.min(0.5, (Math.pow(safeMag, 3) / 1500) + 0.02);

            // Safety check for volume
            const safeVol = Number.isFinite(vol) ? vol : 0;

            // Pan: -180 to 180 -> -1 to 1
            panner.pan.value = q.lon / 180;

            // Connect nodes
            osc.connect(panner);
            panner.connect(gain);
            gain.connect(audioCtx.destination);

            // Envelope (ADSR-ish)
            const now = audioCtx.currentTime + delay; // Apply calculated delay
            osc.start(now);

            // Duration varies by magnitude: Mag 3 = 0.2s, Mag 9 = 1.4s
            const duration = 0.2 + (Math.max(0, safeMag - 3) * 0.2);

            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(safeVol, now + 0.02); // Fast attack
            gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

            osc.stop(now + duration + 0.1);
        }

        // --- Helper Function for Frame Calc ---
        function getFrameCount() {
            const val = parseInt(document.getElementById('frame-number').value);
            return val > 0 ? val : 1;
        }

        // --- Helper to calculate size array for renderer ---
        function calculateScaledSizes(multiplier) {
            const baseSize = parseFloat(document.getElementById('size-slider').value);
            const magBonusScale = parseFloat(document.getElementById('mag-slider').value);
            const sizes = [];
            const MIDPOINT = 1.618;

            for (const q of rawQuakeData) {
                let sizeFactor = q.mag;
                if (q.mag > MIDPOINT) {
                    const diff = q.mag - MIDPOINT;
                    sizeFactor += (Math.pow(diff, 3) * magBonusScale);
                }
                // Apply multiplier to final size
                const s = baseSize * (sizeFactor / 2.5) * multiplier;
                sizes.push(s);
            }
            return sizes;
        }

        // --- Global Error Helper ---
        function showError(msg) {
            const loadingDiv = document.getElementById('loading');
            loadingDiv.innerText = "Error: " + msg;
            loadingDiv.style.color = '#ff4444';
            loadingDiv.style.display = 'block';

            setTimeout(() => {
                loadingDiv.style.display = 'none';
                loadingDiv.style.color = ''; // Reset to default (CSS handles it)
                loadingDiv.innerText = "Initializing...";
            }, 3000);
        }

        // --- UI Logic ---
        function toggleMenu() {
            document.getElementById('side-panel').classList.toggle('open');
        }
        document.getElementById('menu-btn').addEventListener('click', toggleMenu);
        document.getElementById('close-btn').addEventListener('click', toggleMenu);

        // --- Search Logic ---
        function searchLocation() {
            // Close info popup if open
            document.getElementById('quake-info').style.display = 'none';

            const input = document.getElementById('search-input');
            const btn = document.getElementById('search-btn');
            const query = input.value.trim().toLowerCase();

            if (!query) return;

            // Find best match in labels
            const labels = staticLabelArrays.text;
            // First try exact match
            let index = labels.findIndex(name => name.toLowerCase() === query);

            if (index === -1) {
                // Try partial match
                index = labels.findIndex(name => name.toLowerCase().includes(query));
            }

            if (index !== -1) {
                const tx = staticLabelArrays.x[index];
                const ty = staticLabelArrays.y[index];
                const tz = staticLabelArrays.z[index];

                // Calculate normalized vector for Eye Direction (Look from this direction)
                const len = Math.sqrt(tx*tx + ty*ty + tz*tz);
                const nx = tx / len;
                const ny = ty / len;
                const nz = tz / len;

                // Calculate Center Point (The surface point to rotate around)
                const PLOT_SCALE = 3000 / EARTH_RADIUS;
                const cx = (tx / EARTH_RADIUS) * PLOT_SCALE;
                const cy = (ty / EARTH_RADIUS) * PLOT_SCALE;
                const cz = (tz / EARTH_RADIUS) * PLOT_SCALE;

                // Maintain current zoom distance relative to the new center
                const currentDist = Math.sqrt(currentCamera.eye.x**2 + currentCamera.eye.y**2 + currentCamera.eye.z**2);

                // Position eye along the normal vector relative to the surface point
                const newEye = {
                    x: nx * currentDist,
                    y: ny * currentDist,
                    z: nz * currentDist
                };

                const newCenter = { x: cx, y: cy, z: cz };

                // Update camera
                const newCameraSettings = {
                    eye: newEye,
                    center: newCenter,
                    up: { x: 0, y: 0, z: 1 }
                };

                currentCamera = newCameraSettings;
                Plotly.relayout('chart-container', { 'scene.camera': newCameraSettings });

                // Stop rotation so user stays on target
                autoRotate = false;
                document.getElementById('rotate-btn').innerHTML = '▶';

                // Clear input and disable button (No visual text feedback)
                input.value = "";
                btn.disabled = true;

                // Update plot to clear any old markers
                updatePlot();
            }
        }

        function searchVolcano() {
            // Close info popup if open
            document.getElementById('quake-info').style.display = 'none';

            const input = document.getElementById('volc-search-input');
            const btn = document.getElementById('volc-search-btn');
            const query = input.value.trim().toLowerCase();

            if (!query) return;

            // Find best match in rawVolcanoData
            // First try exact match
            let found = rawVolcanoData.find(v => v.name.toLowerCase() === query);

            if (!found) {
                // Try partial match
                found = rawVolcanoData.find(v => v.name.toLowerCase().includes(query));
            }

            if (found) {

                // Center camera on volcano
                const lat = found.lat;
                const lon = found.lon;

                // Calculate normalized vector
                const latRad = lat * Math.PI / 180;
                const lonRad = lon * Math.PI / 180;

                const nx = Math.cos(latRad) * Math.cos(lonRad);
                const ny = Math.cos(latRad) * Math.sin(lonRad);
                const nz = Math.sin(latRad);

                const PLOT_SCALE = 3000 / EARTH_RADIUS;
                const [tx, ty, tz] = latLonToXYZ(lat, lon, EARTH_RADIUS);
                const scx = (tx / EARTH_RADIUS) * PLOT_SCALE;
                const scy = (ty / EARTH_RADIUS) * PLOT_SCALE;
                const scz = (tz / EARTH_RADIUS) * PLOT_SCALE;

                const newCenter = { x: scx, y: scy, z: scz };

                const currentDist = Math.sqrt(currentCamera.eye.x**2 + currentCamera.eye.y**2 + currentCamera.eye.z**2);

                const newEye = {
                    x: nx * currentDist,
                    y: ny * currentDist,
                    z: nz * currentDist
                };

                const newCameraSettings = {
                    eye: newEye,
                    center: newCenter,
                    up: { x: 0, y: 0, z: 1 }
                };

                currentCamera = newCameraSettings;
                Plotly.relayout('chart-container', { 'scene.camera': newCameraSettings });

                autoRotate = false;
                document.getElementById('rotate-btn').innerHTML = '▶';

                // Provide visual feedback
                input.value = "";
                btn.disabled = true;
            }
        }

        function searchZone() {
            const input = document.getElementById('zone-input');
            const btn = document.getElementById('zone-btn');
            const query = input.value.trim();

            // Close info popup if open
            document.getElementById('quake-info').style.display = 'none';

            if (!query) return;

            // Case-insensitive lookup for keys
            let matchedKey = Object.keys(seismicBookmarks).find(k => k.toLowerCase() === query.toLowerCase());

            // Try partial match if exact fails
            if (!matchedKey) {
                matchedKey = Object.keys(seismicBookmarks).find(k => k.toLowerCase().includes(query.toLowerCase()));
            }

            if (matchedKey) {
                const zone = seismicBookmarks[matchedKey];
                // Calculate normalized vector from Lat/Lon
                const latRad = zone.lat * Math.PI / 180;
                const lonRad = zone.lon * Math.PI / 180;

                // Vector for eye direction
                const nx = Math.cos(latRad) * Math.cos(lonRad);
                const ny = Math.cos(latRad) * Math.sin(lonRad);
                const nz = Math.sin(latRad);

                // New Center (Surface point)
                const PLOT_SCALE = 3000 / EARTH_RADIUS;
                const [tx, ty, tz] = latLonToXYZ(zone.lat, zone.lon, EARTH_RADIUS);
                const scx = (tx / EARTH_RADIUS) * PLOT_SCALE;
                const scy = (ty / EARTH_RADIUS) * PLOT_SCALE;
                const scz = (tz / EARTH_RADIUS) * PLOT_SCALE;

                const newCenter = { x: scx, y: scy, z: scz };

                // New Eye (Zoom distance back from center)
                const zoomDist = zone.zoom;
                const newEye = {
                    x: nx * zoomDist,
                    y: ny * zoomDist,
                    z: nz * zoomDist
                };

                const newCam = {
                    eye: newEye,
                    center: newCenter,
                    up: { x: 0, y: 0, z: 1 }
                };

                currentCamera = newCam;
                Plotly.relayout('chart-container', { 'scene.camera': newCam });

                // Stop rotation
                autoRotate = false;
                document.getElementById('rotate-btn').innerHTML = '▶';

                // Clear input and disable button (No visual text feedback)
                input.value = "";
                btn.disabled = true;

                updatePlot();
            }
        }

        // --- Date Helpers ---
        function setDefaultDates() {
            const end = new Date();
            const start = new Date();
            start.setMonth(start.getMonth() - 1);
            document.getElementById('end-date').value = end.toISOString().split('T')[0];
            document.getElementById('start-date').value = start.toISOString().split('T')[0];
        }

        function applyPreset(type) {
            const end = new Date();
            let start = new Date();

            document.getElementById('min-mag-slider').value = "0";
            document.getElementById('max-mag-slider').value = "10";
            document.getElementById('min-depth-filter').value = "0";
            document.getElementById('max-depth-filter').value = "800";

            if (type === '24h') start.setDate(end.getDate() - 1);
            else if (type === '7d') start.setDate(end.getDate() - 7);
            else if (type === '30d') start.setDate(end.getDate() - 30);
            else if (type === 'sig') {
                start.setDate(end.getDate() - 30);
                document.getElementById('min-mag-slider').value = "5.0";
            } else if (type === 'deep') {
                start.setDate(end.getDate() - 365);
                document.getElementById('min-depth-filter').value = "300";
            }

            document.getElementById('end-date').value = end.toISOString().split('T')[0];
            document.getElementById('start-date').value = start.toISOString().split('T')[0];
            updateLabels();
            fetchDataAndPlot(false);
        }

        function latLonToXYZ(lat, lon, radius) {
            const latRad = lat * Math.PI / 180;
            const lonRad = lon * Math.PI / 180;
            const x = radius * Math.cos(latRad) * Math.cos(lonRad);
            const y = radius * Math.cos(latRad) * Math.sin(lonRad);
            const z = radius * Math.sin(latRad);
            return [x, y, z];
        }

        function processBorders(geojson) {
            const bx = [], by = [], bz = [];
            const lx = [], ly = [], lz = [], lt = [];

            geojson.features.forEach(feature => {
                const geometry = feature.geometry;
                if (!geometry) return;

                const name = feature.properties ? feature.properties.name : null;
                const type = geometry.type;

                const candidates = [];

                const processRing = (ring) => {
                    let rMinLat = 90, rMaxLat = -90, rMinLon = 180, rMaxLon = -180;
                    let count = 0;

                    ring.forEach(pt => {
                        const lon = pt[0];
                        const lat = pt[1];

                        const [x, y, z] = latLonToXYZ(lat, lon, EARTH_RADIUS);
                        bx.push(x); by.push(y); bz.push(z);

                        if (lat < rMinLat) rMinLat = lat;
                        if (lat > rMaxLat) rMaxLat = lat;
                        if (lon < rMinLon) rMinLon = lon;
                        if (lon > rMaxLon) rMaxLon = lon;
                        count++;
                    });
                    bx.push(null); by.push(null); bz.push(null);

                    if (count === 0) return null;

                    const latSpan = rMaxLat - rMinLat;
                    const lonSpan = rMaxLon - rMinLon;
                    const area = latSpan * lonSpan;

                    return {
                        lat: (rMinLat + rMaxLat) / 2,
                        lon: (rMinLon + rMaxLon) / 2,
                        area: area
                    };
                };

                if (type === 'Polygon') {
                    const ring = geometry.coordinates[0];
                    const data = processRing(ring);
                    if (data) candidates.push(data);
                } else if (type === 'MultiPolygon') {
                    geometry.coordinates.forEach(poly => {
                        const ring = poly[0];
                        const data = processRing(ring);
                        if (data) candidates.push(data);
                    });
                }

                if (name && candidates.length > 0) {
                    candidates.sort((a, b) => b.area - a.area);
                    const largest = candidates[0];
                    const [cx, cy, cz] = latLonToXYZ(largest.lat, largest.lon, EARTH_RADIUS * 1.01);
                    lx.push(cx); ly.push(cy); lz.push(cz);
                    lt.push(name);
                }
            });

            return {
                borders: { x: bx, y: by, z: bz },
                labels: { x: lx, y: ly, z: lz, text: lt }
            };
        }

        function processPlates(geojson) {
            const px = [], py = [], pz = [];
            geojson.features.forEach(feature => {
                const geometry = feature.geometry;
                const type = geometry.type;
                let lines = [];

                if (type === 'LineString') {
                    lines = [geometry.coordinates];
                } else if (type === 'MultiLineString') {
                    lines = geometry.coordinates;
                }

                lines.forEach(line => {
                    line.forEach(pt => {
                        const [x, y, z] = latLonToXYZ(pt[1], pt[0], EARTH_RADIUS + 2);
                        px.push(x); py.push(y); pz.push(z);
                    });
                    px.push(null); py.push(null); pz.push(null);
                });
            });
            return { x: px, y: py, z: pz };
        }

        function processVolcanoes(csvText) {
            const data = [];
            const lines = csvText.split('\n');
            // Header is: Number,Volcano Name,Country,Region,Latitude,Longitude,Elevation (m),Type,Status,Last Known Eruption
            // We start at index 1 to skip header
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // Simple CSV split (handling simple commas)
                // Note: This specific dataset has simple fields usually, but regex is safer for quoted fields
                const cols = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);

                if (cols.length < 7) continue;

                // Remove quotes if present
                const clean = (str) => str ? str.replace(/^"|"$/g, '') : '';

                const name = clean(cols[1]);
                const lat = parseFloat(cols[4]);
                const lon = parseFloat(cols[5]);
                // Parse Elev as float
                let elev = parseFloat(clean(cols[6]));
                if(isNaN(elev)) elev = 0;

                const type = clean(cols[7]);
                const status = clean(cols[8]);

                if (isNaN(lat) || isNaN(lon)) continue;

                data.push({ name, lat, lon, elev, type, status });
            }
            return data;
        }

        function generateWireframeGrid() {
            const gx = [], gy = [], gz = [];
            for (let lat = -90; lat <= 90; lat += 15) {
                for (let lon = -180; lon <= 180; lon += 5) {
                    const [x, y, z] = latLonToXYZ(lat, lon, EARTH_RADIUS);
                    gx.push(x); gy.push(y); gz.push(z);
                }
                gx.push(null); gy.push(null); gz.push(null);
            }
            for (let lon = -180; lon <= 180; lon += 30) {
                for (let lat = -90; lat <= 90; lat += 5) {
                    const [x, y, z] = latLonToXYZ(lat, lon, EARTH_RADIUS);
                    gx.push(x); gy.push(y); gz.push(z);
                }
                gx.push(null); gy.push(null); gz.push(null);
            }
            return { x: gx, y: gy, z: gz };
        }

        async function resumeRender() {
            const session = RenderSession.check();
            if (!session) return;

            // 1. CRITICAL FIX: Ask for folder IMMEDIATELY to preserve User Gesture
            // We cannot await the network call first, or the browser will block the folder picker.
            let dirHandle;
            try {
                dirHandle = await window.showDirectoryPicker();
            } catch (e) {
                return; // User cancelled
            }

            const loading = document.getElementById('loading');
            loading.style.display = 'block';
            loading.innerText = "Restoring Session...";

            // 2. Restore UI Settings
            const s = session.settings;

            // Restore Theme
            isLightMode = s.isLightMode;
            const themeBtn = document.getElementById('theme-btn');
            if (isLightMode) {
                document.body.classList.add('light-mode');
                themeBtn.innerHTML = '☾';
            } else {
                document.body.classList.remove('light-mode');
                themeBtn.innerHTML = '☀';
            }

            // Restore Frame Slider & Inputs
            document.getElementById('start-date').value = s.startDate;
            document.getElementById('end-date').value = s.endDate;
            document.getElementById('min-mag-slider').value = s.minMag;
            document.getElementById('max-mag-slider').value = s.maxMag;
            document.getElementById('min-depth-filter').value = s.minDepth;
            document.getElementById('max-depth-filter').value = s.maxDepth;
            document.getElementById('limit-select').value = s.limit;

            document.getElementById('color-select').value = s.colorSelect;
            document.getElementById('color-mode').value = s.colorMode;
            document.getElementById('size-slider').value = s.size;
            document.getElementById('mag-slider').value = s.magBonus;
            document.getElementById('depth-slider').value = s.depthScale;

            document.getElementById('filename-pattern').value = s.filename;
            document.getElementById('render-format').value = s.format;
            document.getElementById('render-scale').value = s.scale;

            document.getElementById('borders-checkbox').checked = s.borders;
            document.getElementById('plates-checkbox').checked = s.plates;
            document.getElementById('labels-checkbox').checked = s.labels;
            document.getElementById('volcanoes-checkbox').checked = s.volcanoes;
            document.getElementById('surface-lines-checkbox').checked = s.surfaceLines;

            document.getElementById('frame-number').value = s.frameValue;
            document.getElementById('frame-slider').value = s.frameValue;

            // Force UI labels to update (Frame Count, etc.)
            updateLabels();

            // 3. Fetch Data
            loading.innerText = "Restoring Data...";
            try {
                await fetchDataAndPlot(false);
            } catch (e) {
                alert("Could not download data. Check internet.");
                loading.style.display = 'none';
                return;
            }

            // 4. Restore Camera
            loading.innerText = "Aligning Camera...";
            currentCamera = session.camera;
            await Plotly.relayout('chart-container', { 'scene.camera': session.camera });

            autoRotate = false;
            document.getElementById('rotate-btn').innerHTML = '▶';

            // 5. Start Render (Pass the directory handle we already got!)
            await renderFrames(true, session, dirHandle);
        }

        // Frame Rendering
        async function renderFrames(isResume = false, sessionData = null, preLoadedHandle = null) {
            const loading = document.getElementById('loading');

            if (!window.showDirectoryPicker) { showError("Browser not supported."); return; }

            // --- SETUP VARIABLES ---
            let startIndex = 0;
            let numFrames = getFrameCount();

            if (isResume && sessionData) {
                startIndex = sessionData.progress.current + 1;
                numFrames = sessionData.progress.total;
            } else {
                RenderSession.start(numFrames);
            }

            // Use pre-loaded handle if available (Resume Mode), otherwise ask (New Mode)
            let dirHandle = preLoadedHandle;
            if (!dirHandle) {
                try {
                    loading.innerText = "Select Folder...";
                    dirHandle = await window.showDirectoryPicker();
                } catch (e) {
                    loading.style.display = 'none';
                    return;
                }
            }

            autoRotate = false;
            document.getElementById('rotate-btn').innerHTML = '▶';

            const filenamePattern = document.getElementById('filename-pattern').value;
            const format = document.getElementById('render-format').value;
            const sliderMultiplier = parseFloat(document.getElementById('render-scale').value);

            const graphDiv = document.getElementById('chart-container');
            const originalW = graphDiv.clientWidth;
            const originalH = graphDiv.clientHeight;

            let renderW = originalW * sliderMultiplier;
            let renderH = originalH * sliderMultiplier;
            const MAX_DIM = 8192;
            if (renderW > MAX_DIM || renderH > MAX_DIM) {
                const ratio = renderW / renderH;
                if (renderW > renderH) { renderW = MAX_DIM; renderH = MAX_DIM / ratio; }
                else { renderH = MAX_DIM; renderW = MAX_DIM * ratio; }
            }
            const effectiveMultiplier = renderW / originalW;

            // --- VISUAL SCALING ---
            loading.innerText = "Configuring Scene...";
            loading.style.display = 'block';

            const visualMultiplier = Math.min(effectiveMultiplier, 1.6);
            const scaledMarkerSizes = calculateScaledSizes(visualMultiplier);
            const baseRenderSize = parseFloat(document.getElementById('size-slider').value);
            const scaledVolcanoSize = baseRenderSize * 2.0 * visualMultiplier;
            const scaledBorderWidth = BASE_BORDER_WIDTH * visualMultiplier;
            const scaledPlateWidth = BASE_PLATE_WIDTH * visualMultiplier;
            const originalLabelSize = document.getElementById('labels-checkbox').checked ? 12 : 0;
            const scaledLabelSize = originalLabelSize * visualMultiplier;

            await Plotly.restyle(graphDiv, { 'marker.showscale': false, 'marker.size': [scaledMarkerSizes] }, [7]);
            await Plotly.restyle(graphDiv, { 'marker.size': scaledVolcanoSize }, [4]);
            await Plotly.restyle(graphDiv, { 'line.width': scaledBorderWidth }, [1]);
            await Plotly.restyle(graphDiv, { 'line.width': scaledPlateWidth }, [2]);
            await Plotly.restyle(graphDiv, { 'textfont.size': scaledLabelSize }, [3]);

            const currentCenter = currentCamera.center || {x: 0, y: 0, z: 0};
            const startEye = { ...currentCamera.eye };
            const startUp = { ...currentCamera.up };

            const dx = startEye.x - currentCenter.x;
            const dy = startEye.y - currentCenter.y;
            const dz = startEye.z - currentCenter.z;

            const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            function generateFilename(template, index) {
                const numStr = (index + 1).toString();
                const hashMatch = template.match(/(#+)/);
                let base = template;
                if (hashMatch) {
                    const len = hashMatch[1].length;
                    const padded = numStr.padStart(len, '0');
                    base = template.replace(hashMatch[1], padded);
                } else {
                    base = template + '_' + numStr.padStart(4, '0');
                }
                if (!base.toLowerCase().endsWith('.' + format)) base += '.' + format;
                return base;
            }

            try {
                for (let i = startIndex; i < numFrames; i++) {

                    loading.innerText = `Rendering frame ${i + 1}/${numFrames}...`;

                    const angle = (i / numFrames) * 2 * Math.PI;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    const newDx = dx * cos - dy * sin;
                    const newDy = dx * sin + dy * cos;
                    const newEye = { x: currentCenter.x + newDx, y: currentCenter.y + newDy, z: currentCenter.z + dz };

                    await Plotly.relayout(graphDiv, { 'scene.camera.eye': newEye });
                    await wait(20);

                    let dataUrl = await Plotly.toImage(graphDiv, { format: format, width: renderW, height: renderH });
                    let res = await fetch(dataUrl);
                    let blob = await res.blob();

                    const fileName = generateFilename(filenamePattern, i);
                    const fileHandle = await dirHandle.getFileHandle(fileName, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();

                    // Update session progress AFTER write
                    RenderSession.update(i);

                    dataUrl = null; res = null; blob = null;
                }

                loading.innerText = "Done!";

                RenderSession.complete();

                await Plotly.relayout(graphDiv, { 'scene.camera': { eye: startEye, center: currentCenter, up: startUp } });
                const normalSizes = calculateScaledSizes(1.0);
                await Plotly.restyle(graphDiv, { 'marker.size': baseRenderSize * 2.0 }, [4]);
                await Plotly.restyle(graphDiv, { 'marker.showscale': true, 'marker.size': [normalSizes] }, [7]);
                await Plotly.restyle(graphDiv, { 'line.width': BASE_BORDER_WIDTH }, [1]);
                await Plotly.restyle(graphDiv, { 'line.width': BASE_PLATE_WIDTH }, [2]);
                await Plotly.restyle(graphDiv, { 'textfont.size': originalLabelSize }, [3]);

                setTimeout(() => { loading.style.display = 'none'; loading.innerText = "Initializing..."; }, 2000);

            } catch (err) {
                console.warn(err);
                loading.innerText = "Crash! Refresh page to see 'Resume' button.";
                loading.style.color = "red";
            }
        }

        document.getElementById('render-btn').addEventListener('click', () => renderFrames(false));
        document.getElementById('resume-btn').addEventListener('click', resumeRender);

        async function fetchDataAndPlot(isInitial = false) {
            const loading = document.getElementById('loading');
            loading.style.display = 'block';
            loading.innerText = "Querying USGS...";

            try {
                const start = document.getElementById('start-date').value;
                const end = document.getElementById('end-date').value;
                const minMag = document.getElementById('min-mag-slider').value;
                const maxMag = document.getElementById('max-mag-slider').value;
                const minDepth = document.getElementById('min-depth-filter').value;
                const maxDepth = document.getElementById('max-depth-filter').value;
                const limit = document.getElementById('limit-select').value;

                let url = `${USGS_BASE_URL}&starttime=${start}`;
                if (end) url += `&endtime=${end}`;

                if(parseFloat(minMag) > 0) url += `&minmagnitude=${minMag}`;
                if(parseFloat(maxMag) < 10) url += `&maxmagnitude=${maxMag}`;
                url += `&mindepth=${minDepth}&maxdepth=${maxDepth}`;
                url += `&limit=${limit}`;

                console.log("Fetching: " + url);

                const res = await fetch(url);
                if (!res.ok) throw new Error("API Limit or Network Error");
                const quakeJson = await res.json();

                stats = { maxMag: 0, maxDepth: 0, minTime: Infinity, maxTime: -Infinity, avgMag: 0, minMag: Infinity, minDepth: Infinity };
                let totalMag = 0, count = 0, totalRealMag = 0, totalDepth = 0;

                // Counters for log report
                let magCounts = { "0-3": 0, "3-5": 0, "5-7": 0, "7+": 0 };
                let depthCounts = { "Shallow (<70km)": 0, "Intermediate (70-300km)": 0, "Deep (>300km)": 0 };

                rawQuakeData = quakeJson.features.map(f => {
                    const realMag = f.properties.mag || 0;
                    const visualMag = Math.max(realMag, 0.1);
                    const depth = f.geometry.coordinates[2];
                    const time = f.properties.time;

                    if (realMag < stats.minMag) stats.minMag = realMag;
                    if (realMag > stats.maxMag) stats.maxMag = realMag;
                    if (depth < stats.minDepth) stats.minDepth = depth;
                    if (depth > stats.maxDepth) stats.maxDepth = depth;
                    if (time < stats.minTime) stats.minTime = time;
                    if (time > stats.maxTime) stats.maxTime = time;

                    totalMag += visualMag;
                    totalRealMag += realMag;
                    totalDepth += depth;
                    count++;

                    // Stats logic
                    if (realMag < 3) magCounts["0-3"]++;
                    else if (realMag < 5) magCounts["3-5"]++;
                    else if (realMag < 7) magCounts["5-7"]++;
                    else magCounts["7+"]++;

                    if (depth < 70) depthCounts["Shallow (<70km)"]++;
                    else if (depth < 300) depthCounts["Intermediate (70-300km)"]++;
                    else depthCounts["Deep (>300km)"]++;

                    return {
                        lat: f.geometry.coordinates[1],
                        lon: f.geometry.coordinates[0],
                        depth: depth,
                        mag: visualMag,
                        realMag: realMag,
                        time: time,
                        place: f.properties.place || "Unknown",
                        url: f.properties.url,
                        type: 'quake'
                    };
                });

                if (count === 0) {
                    stats.minMag = 0; stats.maxMag = 0; stats.minDepth = 0; stats.maxDepth = 0;
                    stats.minTime = Date.now(); stats.maxTime = Date.now();
                }

                stats.avgMag = count > 0 ? (totalMag / count) : 0;
                const realAvgMag = count > 0 ? (totalRealMag / count) : 0;
                const avgDepth = count > 0 ? (totalDepth / count) : 0;

                console.log("================ DATA REPORT ================");
                console.log(`Total Events: ${count}`);
                console.log(`Date Range: ${new Date(stats.minTime).toLocaleDateString()} to ${new Date(stats.maxTime).toLocaleDateString()}`);
                console.log(`Magnitude: Min ${stats.minMag.toFixed(2)} | Max ${stats.maxMag.toFixed(2)} | Avg ${realAvgMag.toFixed(2)}`);
                console.log(`Depth: Min ${stats.minDepth.toFixed(1)}km | Max ${stats.maxDepth.toFixed(1)}km`);
                console.log("---------------------------------------------");
                console.table(magCounts);
                console.table(depthCounts);
                console.log("=============================================");

                document.getElementById('info-overlay').innerText = `Data: ${count} earthquakes. Source: USGS.`;

                loading.style.display = 'none';

                // Show all immediately
                updatePlot(isInitial);

            } catch (err) {
                console.error(err);
                loading.innerText = "Error: " + err.message;
            }
        }

        // Helper function to generate circle points on sphere
        function getCirclePoints(lat, lon, radiusKm) {
            const points = { x: [], y: [], z: [] };
            const angularDistance = radiusKm / EARTH_RADIUS; // radians

            const latRad = lat * Math.PI / 180;
            const lonRad = lon * Math.PI / 180;

            const sinLat = Math.sin(latRad);
            const cosLat = Math.cos(latRad);

            // Generate 64 points for the circle
            for (let i = 0; i <= 64; i++) {
                const bearing = (i / 64) * 2 * Math.PI;
                const sinBearing = Math.sin(bearing);
                const cosBearing = Math.cos(bearing);

                const sinLat2 = sinLat * Math.cos(angularDistance) + cosLat * Math.sin(angularDistance) * cosBearing;
                const lat2 = Math.asin(sinLat2);

                const y = sinBearing * Math.sin(angularDistance) * cosLat;
                const x = Math.cos(angularDistance) - sinLat * sinLat2;
                const lon2 = lonRad + Math.atan2(y, x);

                // Convert back to Cartesian
                // Using EARTH_RADIUS + small offset to prevent z-fighting
                const R = EARTH_RADIUS + 20; // Increased to 20 to prevent z-fighting
                points.x.push(R * Math.cos(lat2) * Math.cos(lon2));
                points.y.push(R * Math.cos(lat2) * Math.sin(lon2));
                points.z.push(R * Math.sin(lat2));
            }

            return points;
        }

        function animateGlobe() {
            const graphDiv = document.getElementById('chart-container');
            const scene = graphDiv._fullLayout ? graphDiv._fullLayout.scene : null;

            // Handle Camera Rotation
            if (scene && scene.camera && autoRotate) {
                const cos = Math.cos(ROTATION_SPEED);
                const sin = Math.sin(ROTATION_SPEED);

                const currentEye = currentCamera.eye;
                let currentCenter = currentCamera.center;
                if (!currentCenter || typeof currentCenter.x === 'undefined') {
                    currentCenter = {x: 0, y: 0, z: 0};
                }

                const dx = currentEye.x - currentCenter.x;
                const dy = currentEye.y - currentCenter.y;

                const newDx = dx * cos - dy * sin;
                const newDy = dx * sin + dy * cos;

                const newEye = {
                    x: currentCenter.x + newDx,
                    y: currentCenter.y + newDy,
                    z: currentEye.z
                };

                currentCamera.eye = newEye;

                Plotly.relayout('chart-container', {
                    'scene.camera.eye': newEye
                });
            }

            // Handle Active Pulse Animation
            if (pulseState) {
                const now = performance.now();
                // Physics Speed: km per second
                const speed = 300; // Reduced to 300 as requested

                // Elapsed time in seconds
                const elapsedSeconds = (now - pulseState.startTime) / 1000;

                // Current radius in km
                const currentRadius = elapsedSeconds * speed;

                // Calculate progress (0 to 1)
                const progress = currentRadius / pulseState.maxRadius;

                if (progress < 1) {
                    // Generate circle
                    const circle = getCirclePoints(pulseState.lat, pulseState.lon, currentRadius);

                    // Fade out
                    // Use a slightly gentler fade so it stays visible longer
                    const opacity = 1 - Math.pow(progress, 1.5);
                    // Fade the width too (Simulates thinning/dissipating wave)
                    const width = 5 * opacity;

                    // RGBA Color String for proper opacity handling
                    const colorString = `rgba(255, 255, 255, ${opacity.toFixed(2)})`;

                    Plotly.restyle('chart-container', {
                        'x': [circle.x],
                        'y': [circle.y],
                        'z': [circle.z],
                        'line.color': colorString,
                        'line.width': [width],
                        'visible': true
                    }, [9]);
                } else {
                    // Animation Complete - Ensure it's fully transparent/hidden
                    Plotly.restyle('chart-container', {'visible': false}, [9]);
                    pulseState = null;
                }
            }

            // --- TIMELAPSE LOGIC IN ANIMATION FRAME ---
            if (tlState.active && tlState.playing) {
                const now = performance.now();

                // Advance Time
                // Note: We advance time every frame for smooth scrubber/UI updates
                tlState.currentTime += tlState.speed / 60; // Assuming ~60fps, divide speed

                if (tlState.currentTime >= tlState.endTime) {
                    // LOOP BACK
                    tlState.currentTime = tlState.startTime;
                    // Also reset sound tracker
                    tlState.lastSoundTime = tlState.startTime;
                }

                // Update UI every frame
                const dateObj = new Date(tlState.currentTime);
                document.getElementById('tl-date-display').innerText = dateObj.toISOString().slice(0, 16).replace('T', ' ');

                const percent = ((tlState.currentTime - tlState.startTime) / (tlState.endTime - tlState.startTime)) * 100;
                document.getElementById('tl-scrubber').value = percent;

                // AUDIO LOGIC (Decoupled from visual draw)
                if (tlState.soundEnabled) {
                     // Ensure we don't miss the first quake by checking against startTime - small buffer if lastSoundTime reset
                     let checkTime = tlState.lastSoundTime;
                     if (tlState.currentTime < tlState.lastSoundTime) {
                         // Looped
                         checkTime = tlState.startTime - 1000; // Look slightly before start to catch t=minTime quakes
                         tlState.lastSoundTime = checkTime;
                     }

                     const newQuakes = tlState.sortedData.filter(q =>
                         q.time > checkTime && q.time <= tlState.currentTime
                     );

                     if (newQuakes.length > 0) {
                         // Prioritize by Real Magnitude (Largest First)
                         newQuakes.sort((a, b) => b.realMag - a.realMag);
                         const limit = 1; // Limit to 1 per frame to prevent clipping/muddy audio
                         const count = Math.min(newQuakes.length, limit);

                         // Calculate timing offset within this frame based on simulation duration
                         const simDuration = tlState.currentTime - checkTime;

                         for(let k=0; k < count; k++) {
                             let delay = 0;
                             if (simDuration > 0) {
                                 const quakeOffset = newQuakes[k].time - checkTime;
                                 const relativePos = quakeOffset / simDuration;
                                 // Map relative position (0..1) to frame duration (approx 16ms)
                                 delay = relativePos * (1/60);
                             }
                             playQuakeSound(newQuakes[k], delay);
                         }
                     }
                     tlState.lastSoundTime = tlState.currentTime;
                }

                // THROTTLE CHART UPDATES (Critical for performance)
                if (now - tlState.lastDrawTime > tlState.drawInterval) {
                    updateTimeLapseFrame();
                    tlState.lastDrawTime = now;
                }
            }

            requestAnimationFrame(animateGlobe);
        }

        function saveRenderCamera() {
            // Save the current camera state to LocalStorage
            const camState = {
                eye: currentCamera.eye,
                center: currentCamera.center,
                up: currentCamera.up
            };
            localStorage.setItem('earthquake_render_cam', JSON.stringify(camState));
            console.log("Camera state saved:", camState);
        }

        function restoreRenderCamera() {
            const saved = localStorage.getItem('earthquake_render_cam');
            if (!saved) {
                alert("No saved camera position found.");
                return;
            }
            try {
                const camState = JSON.parse(saved);
                currentCamera = camState;
                Plotly.relayout('chart-container', { 'scene.camera': camState });
                // Disable rotation so user doesn't accidentally move it again
                autoRotate = false;
                document.getElementById('rotate-btn').innerHTML = '▶';
            } catch (e) {
                console.error("Failed to restore camera", e);
            }
        }

        // --- TIME LAPSE FUNCTIONS ---

        async function startTimeLapse() {
            if (rawQuakeData.length === 0) {
                alert("No data loaded!");
                return;
            }

            // Init Audio Context on user interaction
            initAudio();

            const graphDiv = document.getElementById('chart-container');

            // 1. Capture current camera state deeply to avoid reference issues
            let savedCamera = currentCamera;
            if (graphDiv._fullLayout && graphDiv._fullLayout.scene && graphDiv._fullLayout.scene.camera) {
                savedCamera = JSON.parse(JSON.stringify(graphDiv._fullLayout.scene.camera));
                currentCamera = savedCamera; // Update global state
            }

            // Hide Side Panel
            document.getElementById('side-panel').classList.remove('open');
            // Show Control Bar
            document.getElementById('timelapse-bar').classList.add('active');

            // Init State
            tlState.active = true;
            tlState.playing = true;
            document.getElementById('tl-play-btn').innerText = '❚❚';

            tlState.startTime = stats.minTime;
            tlState.endTime = stats.maxTime;
            tlState.currentTime = tlState.startTime;
            tlState.lastSoundTime = tlState.startTime - 1000; // Reset audio tracker slightly before start

            // Pre-Sort Data
            tlState.sortedData = [...rawQuakeData].sort((a,b) => a.time - b.time);

            // 2. CRITICAL FIX: Use a UNIQUE uirevision (Date.now()) instead of a constant string.
            // This forces Plotly to treat this as a fresh interaction session, adopting the
            // 'savedCamera' as the new baseline, rather than snapping back to the state
            // stored under the old 'true' key.
            await Plotly.relayout('chart-container', {
                'uirevision': Date.now().toString(),
                'scene.camera': savedCamera
            });

            // Hide Auxiliary Traces
            await Plotly.restyle('chart-container', { visible: false }, [5, 8]);

            // Initial Draw
            await updateTimeLapseFrame();
        }

        function stopTimeLapse() {
            const graphDiv = document.getElementById('chart-container');
            // Removed manual sync logic as requested

            tlState.active = false;
            tlState.playing = false;
            document.getElementById('timelapse-bar').classList.remove('active');

            // Restore visibility of main trace (show all)
            updatePlot();
        }

        function updateTimeLapseFrame() {
            // "Windowed" Fading Approach with Seamless Loop Support
            const windowEnd = tlState.currentTime;
            const windowStart = windowEnd - tlState.windowSize;

            const depthScale = parseFloat(document.getElementById('depth-slider').value);

            // FIX 1: Calculate base size dynamically using the slider logic, just like calculateScaledSizes
            const baseSizeInput = parseFloat(document.getElementById('size-slider').value);
            const magBonusScale = parseFloat(document.getElementById('mag-slider').value);
            const MIDPOINT = 1.618;

            const selectedPalette = document.getElementById('color-select').value;
            const colorMode = document.getElementById('color-mode').value;

            // Standard filter for current time window
            let visibleQuakes = tlState.sortedData.filter(q => q.time >= windowStart && q.time <= windowEnd);

            // --- WRAP-AROUND LOGIC ---
            // If we are near the start of the loop (windowStart is before minTime),
            // we should also show quakes from the very end of the timeline to create a seamless fade.
            if (windowStart < tlState.startTime) {
                const wrapOverlap = tlState.startTime - windowStart;
                const wrapCutoff = tlState.endTime - wrapOverlap;

                // Grab quakes from end of timeline
                const wrappedQuakes = tlState.sortedData.filter(q => q.time >= wrapCutoff);

                // Add them to visible list, but we need to treat their time specially for fading calculation
                visibleQuakes = visibleQuakes.concat(wrappedQuakes);
            }

            const qx = [], qy = [], qz = [], colors = [], sizes = [];

            // Persistent Colorbar Fix: Add dummy point if no quakes
            if (visibleQuakes.length === 0) {
                qx.push(null); qy.push(null); qz.push(null);
                colors.push(stats.minTime); // Dummy value within range
                sizes.push(0);
            }

            visibleQuakes.forEach(q => {
                const r_quake = EARTH_RADIUS - (q.depth * depthScale);
                const [x, y, z] = latLonToXYZ(q.lat, q.lon, r_quake);
                qx.push(x); qy.push(y); qz.push(z);

                // Fading Logic / "Pop" Logic
                let timeDiff = windowEnd - q.time;

                // Correct timeDiff for wrapped quakes (if quake is from end of timeline but we are at start)
                if (timeDiff < 0) {
                    // This means q.time is bigger than windowEnd (it's from the end of the loop)
                    // The actual time passed in current loop is:
                    // (currentTime - startTime) + (endTime - q.time)
                    timeDiff = (windowEnd - tlState.startTime) + (tlState.endTime - q.time);
                }

                // How "fresh" is this quake? 1.0 = just happened, 0.0 = about to expire
                const freshness = 1 - (timeDiff / tlState.windowSize);

                // 1. Base Size Logic from Slider
                let sizeFactor = q.mag;
                if (q.mag > MIDPOINT) {
                    const diff = q.mag - MIDPOINT;
                    sizeFactor += (Math.pow(diff, 3) * magBonusScale);
                }
                // Visual multiplier 1.6 used in renderFrames, 1.0 in normal plot. Let's use 1.0 for consistency.
                let s = baseSizeInput * (sizeFactor / 2.5);

                // 2. Apply Pop/Fade on top of calculated base size
                if (tlState.popEnabled && freshness > 0.95) {
                    s = s * 2.0; // Pop size
                } else {
                    // Fade size slightly as it gets older? Or keep constant?
                    // Let's keep constant size after pop, maybe slight fade
                    s = s * (0.5 + (0.5 * freshness));
                }
                sizes.push(s);

                // Color Logic
                let val;
                if (colorMode === 'depth') val = q.depth;
                else if (colorMode === 'mag') val = q.mag;
                else val = q.time;
                colors.push(val);
            });

            // --- COLOR SCALE FIX ---
            let cmin, cmax, cTitle;
            let tickmode = 'auto', tickvals = undefined, ticktext = undefined;

            if (colorMode === 'depth') {
                cTitle = 'Depth (km)';
                cmin = 0;
                cmax = Math.ceil(stats.maxDepth / 100) * 100;
            } else if (colorMode === 'mag') {
                cTitle = 'Magnitude';
                cmin = 0;
                cmax = 9;
            } else {
                cTitle = 'Date';
                cmin = stats.minTime;
                cmax = stats.maxTime;

                 // Date Formatting for Colorbar
                const range = cmax - cmin;
                if (range > 0) {
                     tickmode = 'array';
                     // Generate 5 ticks
                     const step = range / 4;
                     tickvals = [cmin, cmin + step, cmin + step*2, cmin + step*3, cmax];
                     ticktext = tickvals.map(t => new Date(t).toISOString().split('T')[0]);
                }
            }

            // Update Plotly Trace 7 (Quakes)
            const updateObj = {
                x: [qx], y: [qy], z: [qz],
                'marker.size': [sizes],
                'marker.color': [colors],
                'marker.cmin': cmin,
                'marker.cmax': cmax,
                'marker.colorscale': selectedPalette,
                'marker.colorbar.tickmode': tickmode,
                'marker.colorbar.tickvals': tickvals,
                'marker.colorbar.ticktext': ticktext
            };

            // Remove Title in Timelapse Mode
            if (tlState.active) {
                 updateObj['marker.colorbar.title.text'] = "";
            } else {
                 updateObj['marker.colorbar.title.text'] = cTitle;
            }

            return Plotly.restyle('chart-container', updateObj, [7]);
        }

        // Time Lapse Event Listeners
        document.getElementById('timelapse-mode-btn').addEventListener('click', startTimeLapse);
        document.getElementById('tl-close-btn').addEventListener('click', stopTimeLapse);

        document.getElementById('tl-play-btn').addEventListener('click', () => {
            tlState.playing = !tlState.playing;
            document.getElementById('tl-play-btn').innerText = tlState.playing ? '❚❚' : '▶';
            // Resume audio context if it was suspended
            initAudio();
        });

        document.getElementById('tl-speed').addEventListener('change', (e) => {
            tlState.speed = parseInt(e.target.value);
        });

        document.getElementById('tl-window').addEventListener('change', (e) => {
            tlState.windowSize = parseInt(e.target.value);
            if (!tlState.playing) updateTimeLapseFrame(); // Update immediately if paused
        });

        document.getElementById('tl-pop-check').addEventListener('change', (e) => {
            tlState.popEnabled = e.target.checked;
            if (!tlState.playing) updateTimeLapseFrame(); // Update immediately if paused
        });

        document.getElementById('tl-sound-check').addEventListener('change', (e) => {
            tlState.soundEnabled = e.target.checked;
            if (e.target.checked) initAudio(); // Ensure audio context is ready
        });

        document.getElementById('tl-scrubber').addEventListener('input', (e) => {
            // Pause while scrubbing for performance
            const wasPlaying = tlState.playing;
            tlState.playing = false;
            document.getElementById('tl-play-btn').innerText = '▶';

            const percent = parseFloat(e.target.value);
            tlState.currentTime = tlState.startTime + ((tlState.endTime - tlState.startTime) * (percent / 100));

            // Update Text
            const dateObj = new Date(tlState.currentTime);
            document.getElementById('tl-date-display').innerText = dateObj.toISOString().slice(0, 16).replace('T', ' ');

            // Reset audio tracker so we don't play a million sounds when scrubbing finishes
            tlState.lastSoundTime = tlState.currentTime;

            updateTimeLapseFrame();
        });


        function updateLabels() {
            document.getElementById('size-val').innerText = parseFloat(document.getElementById('size-slider').value).toFixed(1);
            document.getElementById('mag-val').innerText = parseFloat(document.getElementById('mag-slider').value).toFixed(2);
            document.getElementById('depth-val').innerText = parseFloat(document.getElementById('depth-slider').value).toFixed(1);

            document.getElementById('min-mag-val').innerText = document.getElementById('min-mag-slider').value;
            document.getElementById('max-mag-val').innerText = document.getElementById('max-mag-slider').value;
            document.getElementById('min-depth-filter-val').innerText = document.getElementById('min-depth-filter').value;
            document.getElementById('max-depth-filter-val').innerText = document.getElementById('max-depth-filter').value;

            // Update Scale Label
            document.getElementById('render-scale-val').innerText = document.getElementById('render-scale').value + "x";
        }

        function calculateResponsiveCamera() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const aspectRatio = width / height;
            const baseDistance = 0.9;
            let finalDistance = (aspectRatio >= 1) ? baseDistance : Math.max(1.5, baseDistance / aspectRatio);

            return {
                eye: { x: finalDistance, y: finalDistance, z: finalDistance * 0.5 },
                center: { x: 0, y: 0, z: 0 },
                up: { x: 0, y: 0, z: 1 }
            };
        }

        function updatePlot(isInitial = false) {
            // If Time Lapse is active, don't let this function override the visualization unless we are resetting
            if (tlState.active && !isInitial) return;

            const depthScale = parseFloat(document.getElementById('depth-slider').value);
            const baseSize = parseFloat(document.getElementById('size-slider').value);

            // Checkbox logic replacing slider logic
            const bordersEnabled = document.getElementById('borders-checkbox').checked;
            const platesEnabled = document.getElementById('plates-checkbox').checked;
            const volcanoesEnabled = document.getElementById('volcanoes-checkbox').checked;
            const showLabels = document.getElementById('labels-checkbox').checked;
            const showSurfaceLines = document.getElementById('surface-lines-checkbox').checked;
            const labelSize = showLabels ? 12 : 0;

            // Light Mode check
            // Use dark grey for borders in light mode for better contrast
            const bgColor = isLightMode ? '#f0f0f0' : 'black';
            const gridColor = isLightMode ? '#ccc' : '#333';

            // Modified: Darker Teal for Dark Mode borders, Grey for Light Mode
            const borderColor = isLightMode ? '#666' : '#008888';

            // Lighter blue for plates in light mode to distinguish from grey borders
            const plateColor = isLightMode ? '#2288cc' : '#1565C0';

            const labelColor = isLightMode ? 'rgba(0, 0, 0, 0.7)' : 'rgba(180, 180, 180, 0.9)';

            // Volcano styling based on Light Mode
            const volcColor = isLightMode ? 'white' : 'black';
            const volcLine = isLightMode ? 'black' : 'white';

            // Modified: Constant thick widths for both modes (2px borders, 3px plates)
            // UPDATED: Now using global constants
            const borderWidth = bordersEnabled ? BASE_BORDER_WIDTH : 0;
            const plateWidth = platesEnabled ? BASE_PLATE_WIDTH : 0;

            const selectedPalette = document.getElementById('color-select').value;
            const colorMode = document.getElementById('color-mode').value;

            const qx = [], qy = [], qz = [], ghostSizes = [], colors = [], texts = [];
            const customData = []; // To store full object references for click events
            // Arrays for surface lines
            const slx = [], sly = [], slz = [];
            const lineColors = []; // Array for line colors

            // Volcano lines
            const vlx = [], vly = [], vlz = [];

            // Use shared helper for consistency, multiplier 1 for standard view
            const sizes = calculateScaledSizes(1.0);

            let i = 0;
            for (const q of rawQuakeData) {
                const r_quake = EARTH_RADIUS - (q.depth * depthScale);
                const [x, y, z] = latLonToXYZ(q.lat, q.lon, r_quake);
                qx.push(x); qy.push(y); qz.push(z);

                const s = sizes[i]; // Use pre-calculated size
                ghostSizes.push(Math.max(s * 2, 10));

                // Add full object to custom data
                customData.push(q);

                let val;
                if (colorMode === 'depth') val = q.depth;
                else if (colorMode === 'mag') val = q.mag;
                else val = q.time;

                colors.push(val);

                const d = new Date(q.time);
                const dateStr = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')} ${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`;
                texts.push(
                    `<b>${q.place}</b><br>` +
                    `Date: ${dateStr}<br>` +
                    `Magnitude: ${q.realMag.toFixed(2)}<br>` +
                    `Depth: ${q.depth.toFixed(2)}km`
                );

                // Build Surface Lines (Earthquakes)
                if (showSurfaceLines) {
                      const [sx, sy, sz] = latLonToXYZ(q.lat, q.lon, EARTH_RADIUS);
                      // Line from Surface (sx, sy, sz) to Quake (x, y, z)
                      slx.push(sx); sly.push(sy); slz.push(sz);
                      slx.push(x);  sly.push(y);  slz.push(z);
                      // Add breaks to disconnect lines
                      slx.push(null); sly.push(null); slz.push(null);

                      // Push color values for both vertices and the break
                      lineColors.push(val);
                      lineColors.push(val);
                      lineColors.push(val);
                }

                i++;
            }

            let colorSettings = {
                colorscale: selectedPalette,
                colorbar: {
                    x: 0, len: 0.5, thickness: 15,
                    titlefont: {color: isLightMode ? '#333' : 'white'},
                    tickfont: {color: isLightMode ? '#333' : 'white'}
                }
            };

            if (colorMode === 'depth') {
                colorSettings.title = 'Depth (km)';
                colorSettings.cmin = 0;
                colorSettings.cmax = Math.ceil(stats.maxDepth / 100) * 100;
            } else if (colorMode === 'mag') {
                colorSettings.title = 'Magnitude';
                colorSettings.cmin = 0;
                colorSettings.cmax = 9;
            } else {
                colorSettings.title = 'Date';
                colorSettings.cmin = stats.minTime;
                colorSettings.cmax = stats.maxTime;
            }

            const gridTrace = {
                type: 'scatter3d', mode: 'lines',
                x: staticGridArrays.x, y: staticGridArrays.y, z: staticGridArrays.z,
                line: { color: gridColor, width: 1 }, opacity: 0.5, hoverinfo: 'skip'
            };

            const borderTrace = {
                type: 'scatter3d', mode: 'lines',
                x: staticBorderArrays.x, y: staticBorderArrays.y, z: staticBorderArrays.z,
                line: { color: borderColor, width: borderWidth }, opacity: 0.4, hoverinfo: 'skip',
                visible: borderWidth > 0
            };

            const plateTrace = {
                type: 'scatter3d', mode: 'lines',
                x: staticPlateArrays.x, y: staticPlateArrays.y, z: staticPlateArrays.z,
                line: { color: plateColor, width: plateWidth }, opacity: 0.8, hoverinfo: 'skip',
                visible: plateWidth > 0
            };

            // Prepare Volcano Trace
            const vx = [], vy = [], vz = [], vtext = [], vCustom = [];

            // Loop data if enabled OR if lines are needed
            if (volcanoesEnabled || (showSurfaceLines && volcanoesEnabled)) {
                rawVolcanoData.forEach(v => {
                    // Position Logic: Earth Radius + (Elev_km * depthScale)
                    // Convert meters to km first
                    const r_volc = EARTH_RADIUS + ((v.elev / 1000) * depthScale);
                    const [x, y, z] = latLonToXYZ(v.lat, v.lon, r_volc);

                    if (volcanoesEnabled) {
                        vx.push(x); vy.push(y); vz.push(z);
                        vtext.push(
                            `<b>${v.name}</b><br>` +
                            `Type: ${v.type}<br>` +
                            `Elevation: ${v.elev}m`
                        );
                        vCustom.push({
                            type: 'volcano',
                            name: v.name,
                            lat: v.lat,
                            lon: v.lon,
                            elev: v.elev,
                            volcType: v.type,
                            status: v.status
                        });
                    }

                    // Volcano Surface Lines Logic
                    if (showSurfaceLines && volcanoesEnabled) {
                        // Surface point
                        const [sx, sy, sz] = latLonToXYZ(v.lat, v.lon, EARTH_RADIUS);

                        vlx.push(sx); vly.push(sy); vlz.push(sz);
                        vlx.push(x);  vly.push(y);  vlz.push(z);
                        vlx.push(null); vly.push(null); vlz.push(null);
                    }
                });
            }

            const volcanoTrace = {
                type: 'scatter3d',
                mode: 'markers',
                x: vx, y: vy, z: vz,
                text: vtext,
                hoverinfo: 'text',
                customdata: vCustom,
                marker: {
                    symbol: 'x',
                    size: baseSize,
                    color: volcColor,
                    line: { color: volcLine, width: 1.5 },
                    opacity: 1.0
                },
                visible: volcanoesEnabled
            };

            // Distinct Trace for Volcano Surface Lines (Fixed Color)
            const volcanoLineTrace = {
                type: 'scatter3d',
                mode: 'lines',
                x: vlx, y: vly, z: vlz,
                line: {
                    color: isLightMode ? 'rgba(0,0,0,0.4)' : 'rgba(255,255,255,0.4)',
                    width: 2
                },
                opacity: 0.5,
                hoverinfo: 'skip',
                visible: showSurfaceLines && volcanoesEnabled
            };

            const surfaceLineTrace = {
                type: 'scatter3d',
                mode: 'lines',
                x: slx, y: sly, z: slz,
                line: {
                    color: lineColors,
                    colorscale: selectedPalette,
                    cmin: colorSettings.cmin,
                    cmax: colorSettings.cmax,
                    width: 2,
                    showscale: false
                },
                opacity: 0.3,
                hoverinfo: 'skip',
                visible: showSurfaceLines
            };

            // New Country Labels Trace
            const labelTrace = {
                type: 'scatter3d',
                mode: 'text',
                x: staticLabelArrays.x,
                y: staticLabelArrays.y,
                z: staticLabelArrays.z,
                text: staticLabelArrays.text,
                textfont: {
                    color: labelColor,
                    size: labelSize,
                    family: 'sans-serif'
                },
                hoverinfo: 'none',
                visible: labelSize > 0 // Hide if size is 0
            };

            const quakeTrace = {
                type: 'scatter3d', mode: 'markers',
                x: qx, y: qy, z: qz,
                hoverinfo: 'skip',
                customdata: customData, // Pass full object to click event
                marker: {
                    size: sizes, color: colors,
                    colorscale: colorSettings.colorscale, cmin: colorSettings.cmin, cmax: colorSettings.cmax,
                    colorbar: colorSettings.colorbar, opacity: 1.0, line: { width: 0 }
                }
            };

            const ghostTrace = {
                type: 'scatter3d', mode: 'markers',
                x: qx, y: qy, z: qz,
                text: texts, hoverinfo: 'text',
                customdata: customData, // FIX: Pass full object to ghost trace too!
                marker: { size: ghostSizes, color: 'rgba(0,0,0,0)', opacity: 0.0 }
            };

            // Trace 9: Pulse Animation (Initially Empty)
            // Changed from 'markers' (slow symbol scaling) to 'lines' (fast ring geometry)
            const pulseTrace = {
                type: 'scatter3d',
                mode: 'lines',
                x: [], y: [], z: [],
                hoverinfo: 'none',
                line: {
                    width: 5,
                    color: 'white'
                },
                opacity: 1
            };

            const layout = {
                paper_bgcolor: bgColor,
                plot_bgcolor: bgColor,
                margin: { l: 0, r: 0, t: 0, b: 0 },
                hovermode: 'closest',
                scene: {
                    xaxis: { visible: false, showbackground: false },
                    yaxis: { visible: false, showbackground: false },
                    zaxis: { visible: false, showbackground: false },
                    aspectmode: 'data',
                    dragmode: 'orbit'
                },
                showlegend: false,
                uirevision: 'true' // Add uirevision to allow user interaction to persist across updates
            };

            if (isInitial) {
                currentCamera = calculateResponsiveCamera();
            }
            layout.scene.camera = currentCamera;

            // Updated Trace Order - pulseTrace is Trace 9
            Plotly.react('chart-container', [
                gridTrace, borderTrace, plateTrace, labelTrace,
                volcanoTrace, surfaceLineTrace, volcanoLineTrace,
                quakeTrace, ghostTrace, pulseTrace
            ], layout, {responsive: true});
        }

        // --- Main App Logic ---
        async function initApp() {
            try {
                console.log("Starting application...");
                setDefaultDates();

                // Defaults
                document.getElementById('size-slider').value = "2.5";
                document.getElementById('mag-slider').value = "0.1";
                document.getElementById('depth-slider').value = "2.5";
                document.getElementById('color-select').value = "Hot";
                document.getElementById('color-mode').value = "mag";

                document.getElementById('min-mag-slider').value = "0";
                document.getElementById('max-mag-slider').value = "10";
                document.getElementById('min-depth-filter').value = "0";
                document.getElementById('max-depth-filter').value = "800";

                // Initialize checkboxes
                document.getElementById('borders-checkbox').checked = true;
                document.getElementById('plates-checkbox').checked = true;
                document.getElementById('labels-checkbox').checked = false;
                document.getElementById('volcanoes-checkbox').checked = false;
                document.getElementById('surface-lines-checkbox').checked = false;

                updateLabels();

                console.log("Downloading static map data...");
                document.getElementById('loading').innerText = "Loading Map Data...";

                // Fetch Borders, Plates, AND Volcanoes
                const [borderRes, platesRes, volcanoRes] = await Promise.all([
                    fetch(BORDERS_URL),
                    fetch(PLATES_URL),
                    fetch(VOLCANOES_URL)
                ]);

                const borderJson = await borderRes.json();
                const platesJson = await platesRes.json();
                const volcanoCsv = await volcanoRes.text();

                const processedBorders = processBorders(borderJson);
                staticBorderArrays = processedBorders.borders;
                staticLabelArrays = processedBorders.labels;

                // --- Frame Control Sync ---
                const frameSlider = document.getElementById('frame-slider');
                const frameInput = document.getElementById('frame-number');

                // 1. Slider moves -> Update Input
                frameSlider.addEventListener('input', (e) => {
                    frameInput.value = e.target.value;
                    updateLabels(); // Updates the "Total Frames" text if you have it elsewhere
                });

                // 2. Input types -> Update Slider (visually) but keep exact value
                frameInput.addEventListener('input', (e) => {
                    let val = parseInt(e.target.value);
                    if (!val || val < 1) val = 1;

                    // Update slider visual (it will just max out if value > max)
                    frameSlider.value = val;
                    updateLabels();
                });

                // Process Volcanoes
                rawVolcanoData = processVolcanoes(volcanoCsv);
                console.log(`Loaded ${rawVolcanoData.length} volcanoes.`);

                // Populate Autocomplete (Countries)
                const dataList = document.getElementById('locations-list');
                const uniqueNames = [...new Set(staticLabelArrays.text)].sort();
                uniqueNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    dataList.appendChild(option);
                });

                // Populate Autocomplete (Volcanoes)
                const volcList = document.getElementById('volcanoes-list');
                // Use a Set to avoid duplicates if any
                const uniqueVolcNames = [...new Set(rawVolcanoData.map(v => v.name))].sort();
                uniqueVolcNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    volcList.appendChild(option);
                });

                // Populate Autocomplete (Zones)
                const zonesList = document.getElementById('zones-list');
                Object.keys(seismicBookmarks).forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    zonesList.appendChild(option);
                });

                staticPlateArrays = processPlates(platesJson);
                staticGridArrays = generateWireframeGrid();

                const visualInputs = ['size-slider', 'mag-slider', 'depth-slider'];
                visualInputs.forEach(id => {
                    document.getElementById(id).addEventListener('input', () => {
                        updateLabels();
                        if (tlState.active) {
                             updateTimeLapseFrame();
                        } else {
                             updatePlot();
                        }
                    });
                });

                const filterInputs = ['min-mag-slider', 'max-mag-slider', 'min-depth-filter', 'max-depth-filter'];
                filterInputs.forEach(id => {
                    document.getElementById(id).addEventListener('input', updateLabels);
                });

                // Handle frame slider separately (UI only)
                document.getElementById('render-scale').addEventListener('input', updateLabels);

                // Listen for checkbox change
                document.getElementById('labels-checkbox').addEventListener('change', () => updatePlot());
                document.getElementById('borders-checkbox').addEventListener('change', () => updatePlot());
                document.getElementById('plates-checkbox').addEventListener('change', () => updatePlot());
                document.getElementById('volcanoes-checkbox').addEventListener('change', () => updatePlot());
                document.getElementById('surface-lines-checkbox').addEventListener('change', () => updatePlot());

                // Toggle Logic
                document.getElementById('theme-btn').addEventListener('click', () => {
                    isLightMode = !isLightMode;
                    const btn = document.getElementById('theme-btn');
                    if(isLightMode) {
                        document.body.classList.add('light-mode');
                        btn.innerHTML = '☾'; // Moon icon
                    } else {
                        document.body.classList.remove('light-mode');
                        btn.innerHTML = '☀'; // Sun icon
                    }
                    updatePlot();
                });

                // Rotation Toggle
                document.getElementById('rotate-btn').addEventListener('click', () => {
                    const btn = document.getElementById('rotate-btn');

                    // Case A: User clicked during the 1-second Grace Period
                    if (rotationTimeout) {
                        stopRotation(); // Clears timeout, sets autoRotate=false, sets Icon to ▶
                        return;
                    }

                    // Case B: Standard Toggle
                    if (autoRotate) {
                        stopRotation();
                    } else {
                        autoRotate = true;
                        btn.innerHTML = '❚❚';
                    }
                });

                // Reset View
                document.getElementById('reset-btn').addEventListener('click', () => {
                    // 1. Clear any existing rotation/timers first
                    stopRotation();

                    // 2. Clear search & Reset Camera
                    const defaultCam = calculateResponsiveCamera();
                    currentCamera = defaultCam;
                    Plotly.relayout('chart-container', { 'scene.camera': defaultCam });

                    // 3. UI State: Show "Pause" icon immediately.
                    // This tells the user: "I am active (or about to be). Click me to stop."
                    document.getElementById('rotate-btn').innerHTML = '❚❚';

                    // 4. Update plot (to clear markers etc)
                    updatePlot();

                    // 5. Start Grace Period (1 Second)
                    rotationTimeout = setTimeout(() => {
                        autoRotate = true;
                        rotationTimeout = null; // Clear the reference
                    }, 1000);
                });

                // Render frames
                document.getElementById('render-btn').addEventListener('click', renderFrames);

                // GPS Button
                document.getElementById('gps-btn').addEventListener('click', () => {
                    if (!navigator.geolocation) {
                        showError("Geolocation is not supported.");
                        return;
                    }

                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const lat = position.coords.latitude;
                            const lon = position.coords.longitude;

                            // Move Camera logic (copied/adapted from search)
                            const [tx, ty, tz] = latLonToXYZ(lat, lon, EARTH_RADIUS);

                            // Calculate normalized vector
                            const len = Math.sqrt(tx*tx + ty*ty + tz*tz);
                            const nx = tx / len;
                            const ny = ty / len;
                            const nz = tz / len;

                            const PLOT_SCALE = 3000 / EARTH_RADIUS;
                            const cx = (tx / EARTH_RADIUS) * PLOT_SCALE;
                            const cy = (ty / EARTH_RADIUS) * PLOT_SCALE;
                            const cz = (tz / EARTH_RADIUS) * PLOT_SCALE;

                            const currentDist = Math.sqrt(currentCamera.eye.x**2 + currentCamera.eye.y**2 + currentCamera.eye.z**2);

                            const newEye = {
                                x: nx * currentDist,
                                y: ny * currentDist,
                                z: nz * currentDist
                            };

                            const newCenter = { x: cx, y: cy, z: cz };

                            const newCameraSettings = {
                                eye: newEye,
                                center: newCenter,
                                up: { x: 0, y: 0, z: 1 }
                            };

                            currentCamera = newCameraSettings;
                            Plotly.relayout('chart-container', { 'scene.camera': newCameraSettings });

                            // Stop rotation
                            autoRotate = false;
                            document.getElementById('rotate-btn').innerHTML = '▶';
                        },
                        (error) => {
                            console.warn("GPS Error:", error);
                            let msg = "Location access denied or unavailable.";
                            if (error.code === 1) msg = "Location permission denied.";
                            else if (error.code === 2) msg = "Location unavailable.";
                            else if (error.code === 3) msg = "Location request timed out.";
                            else if (error.message) msg = error.message;

                            showError(msg);
                        },
                        { timeout: 10000, maximumAge: 0, enableHighAccuracy: false }
                    );
                });

                document.getElementById('color-select').addEventListener('change', () => {
                    if (tlState.active) updateTimeLapseFrame();
                    else updatePlot();
                });

                document.getElementById('color-mode').addEventListener('change', () => {
                    if (tlState.active) updateTimeLapseFrame();
                    else updatePlot();
                });

                document.getElementById('load-btn').addEventListener('click', () => fetchDataAndPlot(false));

                // Search Listeners (Countries)
                document.getElementById('search-btn').addEventListener('click', searchLocation);
                document.getElementById('search-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') searchLocation();
                });
                // Validation on Input (Case Insensitive Match)
                document.getElementById('search-input').addEventListener('input', (e) => {
                    const val = e.target.value.trim().toLowerCase();
                    const btn = document.getElementById('search-btn');
                    // Check against country list (case insensitive)
                    const isValid = staticLabelArrays.text.some(name => name.toLowerCase() === val);
                    btn.disabled = !isValid;

                    if (isValid && e.inputType === 'insertReplacementText') {
                       // Direct click from datalist
                       searchLocation();
                       document.getElementById('search-input').blur();
                    }
                });

                // Search Listeners (Volcanoes)
                document.getElementById('volc-search-btn').addEventListener('click', searchVolcano);
                document.getElementById('volc-search-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') searchVolcano();
                });
                // Validation on Input (Case Insensitive Match)
                document.getElementById('volc-search-input').addEventListener('input', (e) => {
                    const val = e.target.value.trim().toLowerCase();
                    const btn = document.getElementById('volc-search-btn');
                    // Check against volcano list (case insensitive)
                    const isValid = rawVolcanoData.some(v => v.name.toLowerCase() === val);
                    // Partial match logic for button enable
                    const isPartial = rawVolcanoData.some(v => v.name.toLowerCase().includes(val));
                    btn.disabled = !(isValid || (val.length > 2 && isPartial));

                    if (isValid && e.inputType === 'insertReplacementText') {
                       // Direct click from datalist
                       searchVolcano();
                       document.getElementById('volc-search-input').blur();
                    }
                });

                // Simulate Button
                document.getElementById('qi-sim-btn').addEventListener('click', () => {
                    if (selectedQuake) {
                        // SYNC CAMERA HERE
                        const graphDiv = document.getElementById('chart-container');
                        if (graphDiv._fullLayout && graphDiv._fullLayout.scene && graphDiv._fullLayout.scene.camera) {
                            currentCamera = JSON.parse(JSON.stringify(graphDiv._fullLayout.scene.camera));
                        }

                        // Trigger the wave
                        triggerPulse(selectedQuake);

                        // Center camera on it (fixed jump issue)
                        executeFlyTo(selectedQuake);
                    }
                });

                // Search Listeners (Zones)
                document.getElementById('zone-btn').addEventListener('click', searchZone);
                document.getElementById('zone-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') searchZone();
                });
                // Validation on Input (Case Insensitive Match)
                document.getElementById('zone-input').addEventListener('input', (e) => {
                    const val = e.target.value.trim().toLowerCase();
                    const btn = document.getElementById('zone-btn');
                    // Check against zone keys (case insensitive)
                    const isValid = Object.keys(seismicBookmarks).some(k => k.toLowerCase() === val);
                    btn.disabled = !isValid;

                    if (isValid && e.inputType === 'insertReplacementText') {
                       // Direct click from datalist
                       searchZone();
                       document.getElementById('zone-input').blur();
                    }
                });

                await fetchDataAndPlot(true);

                // --- INTERACTION LOGIC ---
                const graphDiv = document.getElementById('chart-container');
                const stopRotation = () => {
                    // 1. Cancel the grace period timer if it's running
                    if (rotationTimeout) {
                        clearTimeout(rotationTimeout);
                        rotationTimeout = null;
                    }
                    // 2. Stop actual rotation
                    autoRotate = false;
                    // 3. Update UI to "Play" icon (meaning we are currently paused)
                    document.getElementById('rotate-btn').innerHTML = '▶';
                };

                // HANDSHAKE STATE
                // We separate the "Data Availability" (from Plotly) and the "Interaction Complete" (from DOM)
                let interactionState = {
                    isDragging: false,
                    startX: 0,
                    startY: 0,
                    pointData: null,       // Stores data from plotly_click
                    awaitingData: false    // True if mouseup happened but plotly_click hasn't fired yet
                };

                // 1. Pointer Down: Reset everything
                graphDiv.addEventListener('pointerdown', (e) => {
                    stopRotation();

                    // Close Side Panel if open
                    const panel = document.getElementById('side-panel');
                    if (panel.classList.contains('open')) {
                        panel.classList.remove('open');
                    }

                    interactionState.isDragging = false;
                    interactionState.startX = e.clientX;
                    interactionState.startY = e.clientY;
                    interactionState.pointData = null;
                    interactionState.awaitingData = false;
                }, {capture: true});

                // 2. Pointer Move: Detect Drag
                graphDiv.addEventListener('pointermove', (e) => {
                    const dx = Math.abs(e.clientX - interactionState.startX);
                    const dy = Math.abs(e.clientY - interactionState.startY);

                    if (dx > 3 || dy > 3) {
                        interactionState.isDragging = true;
                    }
                }, {capture: true});

                // 3. Plotly Click: Capture Data (Don't move yet unless waiting)
                graphDiv.on('plotly_click', function(data){
                    if(!data || !data.points || data.points.length === 0) return;

                    // Store the data
                    interactionState.pointData = data.points[0].customdata;

                    // If mouseup already happened (race condition), execute immediately
                    if (interactionState.awaitingData && !interactionState.isDragging) {
                        executeFlyTo(interactionState.pointData);
                        interactionState.awaitingData = false;
                    }
                });

                // 4. Pointer Up: The Trigger
                graphDiv.addEventListener('pointerup', (e) => {
                    if (interactionState.isDragging) return; // It was a drag, ignore

                    if (interactionState.pointData) {
                        // We already have data (plotly_click fired on down or during press)
                        executeFlyTo(interactionState.pointData);
                        interactionState.pointData = null; // Clear to prevent double fire
                    } else {
                        // We clicked, but Plotly hasn't sent data yet. Wait for it.
                        interactionState.awaitingData = true;
                        // Timeout to reset if we clicked empty space
                        setTimeout(() => { interactionState.awaitingData = false; }, 200);
                    }
                }, {capture: true});

                // Helper to perform the action
                function executeFlyTo(q) {
                    if (!q) return;

                    const graphDiv = document.getElementById('chart-container');
                    // --- CAMERA SYNC ---
                    // Sync before calculating new target to avoid snap-back
                    // This fixes issues where interactions after timelapse/search used stale coordinates
                    if (graphDiv._fullLayout && graphDiv._fullLayout.scene && graphDiv._fullLayout.scene.camera) {
                        currentCamera = JSON.parse(JSON.stringify(graphDiv._fullLayout.scene.camera));
                    }

                    // Store global selection
                    selectedQuake = q;

                    // Update Popup Content
                    document.getElementById('qi-place').innerText = q.name || q.place;

                    const label1 = document.getElementById('qi-label-1');
                    const val1 = document.getElementById('qi-val-1');
                    const label2 = document.getElementById('qi-label-2');
                    const val2 = document.getElementById('qi-val-2');
                    const label3 = document.getElementById('qi-label-3');
                    const val3 = document.getElementById('qi-val-3');
                    const link = document.getElementById('qi-link');
                    const simBtn = document.getElementById('qi-sim-btn');

                    if (q.type === 'volcano') {
                        label1.innerText = "Type:";
                        val1.innerText = q.volcType;

                        label2.innerText = "Elevation:";
                        val2.innerText = q.elev + "m";

                        label3.innerText = "Status:";
                        val3.innerText = q.status;

                        link.style.display = 'none';
                        simBtn.style.display = 'none'; // No wave simulation for volcanoes
                    } else {
                        label1.innerText = "Magnitude:";
                        val1.innerText = q.realMag.toFixed(2);

                        label2.innerText = "Depth:";
                        val2.innerText = q.depth.toFixed(1) + " km";

                        label3.innerText = "Time:";
                        // Fix popup time format here
                        const d = new Date(q.time);
                        const dateStr = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')} ${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`;
                        val3.innerText = dateStr;

                        if (q.url) {
                            link.href = q.url;
                            link.style.display = 'block';
                        } else {
                            link.style.display = 'none';
                        }
                        simBtn.style.display = 'block'; // Enable for quakes
                    }

                    document.getElementById('quake-info').style.display = 'block';

                    // Fly Camera
                    const PLOT_SCALE = 3000 / EARTH_RADIUS;
                    // For volcanoes, depth is 0 (or negative technically), but we use 0 offset here
                    // For quakes, we use depth slider
                    let r_final = EARTH_RADIUS;
                    if(q.type === 'quake') {
                        r_final -= (q.depth * parseFloat(document.getElementById('depth-slider').value));
                    }
                    if(q.type === 'volcano') {
                        r_final += (q.elev / 1000 * parseFloat(document.getElementById('depth-slider').value));
                    }

                    const [x, y, z] = latLonToXYZ(q.lat, q.lon, r_final);

                    // Apply Plot Scale
                    const scx = (x / EARTH_RADIUS) * PLOT_SCALE;
                    const scy = (y / EARTH_RADIUS) * PLOT_SCALE;
                    const scz = (z / EARTH_RADIUS) * PLOT_SCALE;

                    const newCenter = { x: scx, y: scy, z: scz };

                    const newCamera = {
                        eye: { ...currentCamera.eye }, // Keep zoom level
                        center: newCenter, // Look at point
                        up: { ...currentCamera.up }
                    };

                    currentCamera = newCamera;
                    Plotly.relayout('chart-container', { 'scene.camera': newCamera });
                }

                // Helper: Trigger the pulse animation given a quake object
                function triggerPulse(q) {
                    if (!q || q.type === 'volcano') return;

                    // Calculate Felt Radius based on Magnitude
                    // Exponential scale: roughly M4=140km, M5=280km, M7=1000km, M9=4000km
                    // Ensure visible minimum for small quakes
                    const animMaxRadius = Math.max(500, Math.exp(q.realMag / 1.5) * 20);

                    // Initialize Pulse Animation State
                    // Store origin LAT/LON to calculate the circle correctly on sphere surface
                    pulseState = {
                        startTime: performance.now(),
                        lat: q.lat,
                        lon: q.lon,
                        maxRadius: animMaxRadius
                    };
                }

                // --- EVENT BASED CAMERA TRACKING (No polling) ---
                graphDiv.on('plotly_relayout', (eventData) => {
                    if (eventData['scene.camera']) {
                        currentCamera = eventData['scene.camera'];
                    }
                    else {
                       // Standard fallback, don't aggressively sync fullLayout here
                    }
                });

                graphDiv.addEventListener('touchstart', stopRotation);
                graphDiv.addEventListener('wheel', stopRotation);

                // Global Key Listener for Escape
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        const panel = document.getElementById('side-panel');
                        const popup = document.getElementById('quake-info');

                        if (panel.classList.contains('open')) {
                            panel.classList.remove('open');
                            return;
                        }

                        if (popup.style.display !== 'none') {
                            popup.style.display = 'none';
                        }
                    }
                });

                requestAnimationFrame(animateGlobe);
                initResumeCheck();

            } catch (err) {
                console.error("Critical Error:", err);
                document.getElementById('loading').innerText = "Error initializing app.";
            }
        }

        // --- INITIALIZATION CHECK ---
        // Run this when the app loads to see if we crashed previously
        function initResumeCheck() {
            const session = RenderSession.check();
            if (session) {
                const container = document.getElementById('resume-container');
                const text = document.getElementById('resume-text');

                container.style.display = 'block';
                text.innerText = `Previous render stopped at frame ${session.progress.current + 1} of ${session.progress.total}.`;
            }
        }

        initApp();
    </script>
</body>
</html>
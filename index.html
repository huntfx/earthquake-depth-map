<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Earthquake Depth Map</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

    <style>
        body, html { margin: 0; padding: 0; height: 100%; background-color: black; font-family: sans-serif; overflow: hidden; }

        #menu-btn {
            position: absolute; top: 15px; left: 15px;
            background: rgba(0, 0, 0, 0.6);
            color: cyan;
            border: 1px solid cyan;
            border-radius: 4px;
            font-size: 20px;
            padding: 5px 12px;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.2s;
        }
        #menu-btn:hover { background: rgba(0, 255, 255, 0.2); }

        #side-panel {
            position: fixed;
            top: 0; left: -340px;
            width: 300px;
            height: 100%;
            background: rgba(20, 20, 20, 0.95);
            border-right: 1px solid #333;
            box-shadow: 2px 0 15px rgba(0,0,0,0.8);
            z-index: 1002;
            transition: left 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
        }

        #side-panel.open { left: 0; }

        #close-btn {
            position: absolute; top: 15px; right: 15px;
            background: none; border: none; color: #666;
            font-size: 24px; cursor: pointer;
        }
        #close-btn:hover { color: white; }

        h2 { margin: 0 0 20px 0; font-size: 22px; color: cyan; border-bottom: 1px solid #333; padding-bottom: 15px; }
        h3 { margin: 20px 0 10px 0; font-size: 14px; color: #888; text-transform: uppercase; border-bottom: 1px solid #444; padding-bottom: 5px; }
        h3:first-of-type { margin-top: 0; }

        .control-group { margin-bottom: 15px; width: 100%; }

        label { display: block; font-size: 12px; margin-bottom: 5px; color: #aaa; font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px;}
        span.val { color: white; float: right; }

        input[type=range] {
            width: 100%; cursor: pointer; accent-color: cyan;
            height: 4px; background: #444; border-radius: 2px;
        }

        input[type=date] {
            width: 100%; background: #333; color: white; border: 1px solid #555;
            padding: 5px; border-radius: 3px; font-family: sans-serif;
            box-sizing: border-box;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #333;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #555;
            margin-bottom: 15px;
        }
        .checkbox-group label { margin: 0; cursor: pointer; color: white; }
        input[type=checkbox] { width: 16px; height: 16px; cursor: pointer; accent-color: cyan; }

        .preset-group { display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 15px; }
        .preset-btn {
            flex: 1 1 30%; background: #333; color: #ddd; border: 1px solid #555;
            padding: 8px 5px; font-size: 11px; cursor: pointer; border-radius: 3px;
            transition: all 0.2s; text-transform: uppercase; font-weight: bold;
            white-space: nowrap;
        }
        .preset-btn:hover { background: #444; border-color: cyan; color: cyan; }

        select {
            background: #333; color: white; border: 1px solid #555;
            padding: 8px; border-radius: 3px; width: 100%; font-size: 13px; cursor: pointer;
        }

        #load-btn {
            width: 100%; background: cyan; color: black; border: none;
            padding: 10px; font-weight: bold; cursor: pointer;
            margin-bottom: 20px; border-radius: 4px;
            text-transform: uppercase; letter-spacing: 1px;
            transition: background 0.2s;
        }
        #load-btn:hover { background: #ccffff; }

        #chart-container { height: 100vh; width: 100%; }

        #info-overlay {
            position: absolute; bottom: 15px; left: 15px;
            color: rgba(255,255,255,0.5); font-size: 11px;
            pointer-events: none; user-select: none;
            z-index: 5;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 4px;
        }

        #loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: cyan; font-size: 24px; font-weight: bold;
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; z-index: 2000;
        }
    </style>
</head>
<body>

    <div id="loading">Initializing...</div>

    <button id="menu-btn">☰ Settings</button>

    <div id="side-panel">
        <button id="close-btn">×</button>
        <h2>Earthquake<br>Depth Map</h2>

        <h3>Presets</h3>
        <div class="preset-group">
            <button class="preset-btn" onclick="applyPreset('24h')">Last 24h</button>
            <button class="preset-btn" onclick="applyPreset('7d')">Last 7d</button>
            <button class="preset-btn" onclick="applyPreset('30d')">Last 30d</button>
            <button class="preset-btn" onclick="applyPreset('sig')">Major (>5)</button>
            <button class="preset-btn" onclick="applyPreset('deep')">Deep (>300km)</button>
        </div>

        <h3>Data Filters</h3>

        <div class="control-group">
            <label>Start Date</label>
            <input type="date" id="start-date">
        </div>
        <div class="control-group">
            <label>End Date</label>
            <input type="date" id="end-date">
        </div>

        <div class="control-group">
            <label>Min Magnitude: <span id="min-mag-val" class="val">0.0</span></label>
            <input type="range" id="min-mag-slider" min="0" max="9" step="0.1" value="0">
        </div>
        <div class="control-group">
            <label>Max Magnitude: <span id="max-mag-val" class="val">10.0</span></label>
            <input type="range" id="max-mag-slider" min="0" max="10" step="0.1" value="10">
        </div>

        <div class="control-group">
            <label>Min Depth (km): <span id="min-depth-filter-val" class="val">0</span></label>
            <input type="range" id="min-depth-filter" min="0" max="800" step="10" value="0">
        </div>
        <div class="control-group">
            <label>Max Depth (km): <span id="max-depth-filter-val" class="val">800</span></label>
            <input type="range" id="max-depth-filter" min="0" max="800" step="10" value="800">
        </div>

        <div class="control-group">
            <label>Max Results</label>
            <select id="limit-select">
                <option value="1000">1,000</option>
                <option value="5000">5,000</option>
                <option value="10000" selected>10,000</option>
                <option value="20000">20,000</option>
            </select>
        </div>

        <button id="load-btn">Load Data</button>

        <h3>Visualization</h3>

        <div class="control-group">
            <label>Palette</label>
            <select id="color-select">
                <option value="Hot" selected>Hot</option>
                <option value="YlGnBu">YlGnBu</option>
                <option value="Rainbow">Rainbow</option>
                <option value="YlOrRd">YlOrRd</option>
                <option value="Greys">Greys</option>
                <option value="Electric">Electric</option>
            </select>
        </div>

        <div class="control-group">
            <label>Colour By</label>
            <select id="color-mode">
                <option value="mag" selected>Magnitude</option>
                <option value="depth">Depth</option>
                <option value="date">Date</option>
            </select>
        </div>

        <div class="control-group">
            <label>Point Size: <span id="size-val" class="val">2.5</span></label>
            <input type="range" id="size-slider" min="0.5" max="5.0" step="0.5">
        </div>

        <div class="control-group">
            <label>Magnitude Bonus: <span id="mag-val" class="val">0.1</span></label>
            <input type="range" id="mag-slider" min="0" max="1" step="0.01">
        </div>

        <div class="control-group">
            <label>Depth Scale: <span id="depth-val" class="val">2.5</span></label>
            <input type="range" id="depth-slider" min="1" max="5" step="0.5">
        </div>

        <div class="control-group">
            <label>Border Width: <span id="border-val" class="val">1</span></label>
            <input type="range" id="border-slider" min="0" max="4" step="1" value="1">
        </div>

        <div class="control-group">
            <label>Plate Width: <span id="plate-width-val" class="val">2</span></label>
            <input type="range" id="plate-width-slider" min="0" max="4" step="1" value="2">
        </div>
    </div>

    <div id="chart-container"></div>
    <div id="info-overlay">Waiting for data...</div>

    <script>
        // --- Constants ---
        const EARTH_RADIUS = 6371;
        const USGS_BASE_URL = "https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&orderby=magnitude";
        const BORDERS_URL = "https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json";
        const PLATES_URL = "https://raw.githubusercontent.com/fraxen/tectonicplates/master/GeoJSON/PB2002_boundaries.json";

        const BORDER_WIDTHS = [0, 1, 2, 4, 8, 16];
        const ROTATION_SPEED = -0.001;

        // --- State ---
        let rawQuakeData = [];
        let stats = { maxMag: 0, maxDepth: 0, minTime: 0, maxTime: 0, avgMag: 0 };

        let staticBorderArrays = { x: [], y: [], z: [] };
        let staticPlateArrays = { x: [], y: [], z: [] };
        let staticGridArrays = { x: [], y: [], z: [] };

        // Single Source of Truth for Camera
        let currentCamera = {
            eye: {x: 1.5, y: 1.5, z: 1.5},
            center: {x: 0, y: 0, z: 0},
            up: {x: 0, y: 0, z: 1}
        };

        let autoRotate = true;
        let frameCounter = 0;

        // --- UI Logic ---
        function toggleMenu() {
            document.getElementById('side-panel').classList.toggle('open');
        }
        document.getElementById('menu-btn').addEventListener('click', toggleMenu);
        document.getElementById('close-btn').addEventListener('click', toggleMenu);

        // --- Date Helpers ---
        function setDefaultDates() {
            const end = new Date();
            const start = new Date();
            start.setMonth(start.getMonth() - 1);
            document.getElementById('end-date').value = end.toISOString().split('T')[0];
            document.getElementById('start-date').value = start.toISOString().split('T')[0];
        }

        function applyPreset(type) {
            const end = new Date();
            let start = new Date();

            document.getElementById('min-mag-slider').value = "0";
            document.getElementById('max-mag-slider').value = "10";
            document.getElementById('min-depth-filter').value = "0";
            document.getElementById('max-depth-filter').value = "800";

            if (type === '24h') start.setDate(end.getDate() - 1);
            else if (type === '7d') start.setDate(end.getDate() - 7);
            else if (type === '30d') start.setDate(end.getDate() - 30);
            else if (type === 'sig') {
                start.setDate(end.getDate() - 30);
                document.getElementById('min-mag-slider').value = "5.0";
            } else if (type === 'deep') {
                start.setDate(end.getDate() - 365);
                document.getElementById('min-depth-filter').value = "300";
            }

            document.getElementById('end-date').value = end.toISOString().split('T')[0];
            document.getElementById('start-date').value = start.toISOString().split('T')[0];
            updateLabels();
            fetchDataAndPlot(false);
        }

        function latLonToXYZ(lat, lon, radius) {
            const latRad = lat * Math.PI / 180;
            const lonRad = lon * Math.PI / 180;
            const x = radius * Math.cos(latRad) * Math.cos(lonRad);
            const y = radius * Math.cos(latRad) * Math.sin(lonRad);
            const z = radius * Math.sin(latRad);
            return [x, y, z];
        }

        function processBorders(geojson) {
            const bx = [], by = [], bz = [];
            geojson.features.forEach(feature => {
                const geometry = feature.geometry;
                if (!geometry) return;

                // FIX: Removed extra array wrapping that caused distortion
                const polygons = (geometry.type === 'Polygon') ? geometry.coordinates : geometry.coordinates;

                polygons.forEach(poly => {
                    const actualPoly = (geometry.type === 'MultiPolygon') ? poly[0] : poly;
                    actualPoly.forEach(pt => {
                        const [x, y, z] = latLonToXYZ(pt[1], pt[0], EARTH_RADIUS);
                        bx.push(x); by.push(y); bz.push(z);
                    });
                    bx.push(null); by.push(null); bz.push(null);
                });
            });
            return { x: bx, y: by, z: bz };
        }

        function processPlates(geojson) {
            const px = [], py = [], pz = [];
            geojson.features.forEach(feature => {
                const geometry = feature.geometry;
                const type = geometry.type;
                let lines = [];

                if (type === 'LineString') {
                    lines = [geometry.coordinates];
                } else if (type === 'MultiLineString') {
                    lines = geometry.coordinates;
                }

                lines.forEach(line => {
                    line.forEach(pt => {
                        const [x, y, z] = latLonToXYZ(pt[1], pt[0], EARTH_RADIUS + 2);
                        px.push(x); py.push(y); pz.push(z);
                    });
                    px.push(null); py.push(null); pz.push(null);
                });
            });
            return { x: px, y: py, z: pz };
        }

        function generateWireframeGrid() {
            const gx = [], gy = [], gz = [];
            for (let lat = -90; lat <= 90; lat += 15) {
                for (let lon = -180; lon <= 180; lon += 5) {
                    const [x, y, z] = latLonToXYZ(lat, lon, EARTH_RADIUS);
                    gx.push(x); gy.push(y); gz.push(z);
                }
                gx.push(null); gy.push(null); gz.push(null);
            }
            for (let lon = -180; lon <= 180; lon += 30) {
                for (let lat = -90; lat <= 90; lat += 5) {
                    const [x, y, z] = latLonToXYZ(lat, lon, EARTH_RADIUS);
                    gx.push(x); gy.push(y); gz.push(z);
                }
                gx.push(null); gy.push(null); gz.push(null);
            }
            return { x: gx, y: gy, z: gz };
        }

        // --- Main App Logic ---
        async function initApp() {
            try {
                console.log("Starting application...");
                setDefaultDates();

                // Defaults
                document.getElementById('size-slider').value = "2.5";
                document.getElementById('mag-slider').value = "0.1";
                document.getElementById('depth-slider').value = "2.5";
                document.getElementById('border-slider').value = "1";
                document.getElementById('plate-width-slider').value = "2";
                document.getElementById('color-select').value = "Hot";
                document.getElementById('color-mode').value = "mag";

                document.getElementById('min-mag-slider').value = "0";
                document.getElementById('max-mag-slider').value = "10";
                document.getElementById('min-depth-filter').value = "0";
                document.getElementById('max-depth-filter').value = "800";

                updateLabels();

                console.log("Downloading static map data...");
                document.getElementById('loading').innerText = "Loading Map Data...";

                const [borderRes, platesRes] = await Promise.all([
                    fetch(BORDERS_URL),
                    fetch(PLATES_URL)
                ]);

                const borderJson = await borderRes.json();
                const platesJson = await platesRes.json();

                staticBorderArrays = processBorders(borderJson);
                staticPlateArrays = processPlates(platesJson);
                staticGridArrays = generateWireframeGrid();

                const inputs = ['size-slider', 'mag-slider', 'depth-slider', 'border-slider', 'min-mag-slider', 'max-mag-slider', 'min-depth-filter', 'max-depth-filter', 'plate-width-slider'];
                inputs.forEach(id => {
                    document.getElementById(id).addEventListener('input', () => {
                        updateLabels();
                        const isFilter = id.includes('min') || id.includes('max') || id.includes('filter');
                        if(!isFilter) updatePlot();
                    });
                });

                document.getElementById('color-select').addEventListener('change', () => updatePlot());
                document.getElementById('color-mode').addEventListener('change', () => updatePlot());

                document.getElementById('load-btn').addEventListener('click', () => fetchDataAndPlot(false));

                await fetchDataAndPlot(true);

                // --- INTERACTION LOGIC ---
                const graphDiv = document.getElementById('chart-container');
                const stopRotation = () => { autoRotate = false; };

                graphDiv.addEventListener('mousedown', (e) => {
                    stopRotation();
                });

                // --- EVENT BASED CAMERA TRACKING (No polling) ---
                // We listen for EVERY camera change event from Plotly and update our single source of truth.
                graphDiv.on('plotly_relayout', (eventData) => {
                    // eventData can be like: { 'scene.camera': {...} } OR { 'scene.camera.eye': {...} }

                    // Case 1: Full Camera update
                    if (eventData['scene.camera']) {
                        currentCamera = eventData['scene.camera'];
                    }
                    // Case 2: Partial updates (e.g. just eye/zoom)
                    else {
                        // If we get partial data, we need to carefully merge it.
                        // However, parsing "scene.camera.eye.x" keys is tedious.
                        // Easier strategy: When ANY relayout happens, read the FULL calculated camera from the graph.
                        // This avoids the "1 frame lag" because relayout fires AFTER the visual update.
                        if (graphDiv._fullLayout && graphDiv._fullLayout.scene && graphDiv._fullLayout.scene.camera) {
                            const cam = graphDiv._fullLayout.scene.camera;
                            // Update our global truth
                            currentCamera = {
                                eye: { ...cam.eye },
                                center: { ...cam.center },
                                up: { ...cam.up }
                            };
                        }
                    }
                });

                // Strict Left-Click detection for "Click to Center"
                let isMouseDown = false;
                let startMousePos = {x:0, y:0};

                graphDiv.addEventListener('mousedown', (e) => {
                    if(e.button === 0) {
                        isMouseDown = true;
                        startMousePos = {x: e.clientX, y: e.clientY};
                    }
                });

                graphDiv.addEventListener('mouseup', (e) => {
                    if(!isMouseDown) return;
                    isMouseDown = false;
                    const dx = Math.abs(e.clientX - startMousePos.x);
                    const dy = Math.abs(e.clientY - startMousePos.y);
                    // If moved less than 5px, consider it a click, otherwise it was a drag/rotate
                    if(dx < 5 && dy < 5) {
                        // It was a click! We wait for Plotly's click event to give us the data point
                        // But we handle the logic inside the plotly_click handler
                    }
                });

                graphDiv.on('plotly_click', function(data){
                    // We only care if we are NOT rotating/dragging.
                    // The mouseup logic above is for browser events, but Plotly's click
                    // fires nicely for points. We just need to ensure we didn't drag.
                    // We can check if autoRotate is off (it stops on mousedown)

                    // Double check drag distance logic inside here?
                    // Actually, simpler: if autoRotate was stopped, we might be dragging.
                    // Let's rely on a small heuristic:
                    // If the user drags, the camera position changes.
                    // If the user clicks, the camera position effectively stays the same between down and up.

                    if(!data || !data.points || data.points.length === 0) return;

                    // Just execute the move. The user wants to see this point.
                    const pt = data.points[0];
                    const PLOT_SCALE = 3000 / EARTH_RADIUS;
                    const cx = (pt.x / EARTH_RADIUS) * PLOT_SCALE;
                    const cy = (pt.y / EARTH_RADIUS) * PLOT_SCALE;
                    const cz = (pt.z / EARTH_RADIUS) * PLOT_SCALE;

                    const newCamera = {
                        eye: { ...currentCamera.eye }, // Keep zoom
                        center: { x: cx, y: cy, z: cz }, // Move target
                        up: { ...currentCamera.up }
                    };

                    // Update Plotly AND our tracker
                    currentCamera = newCamera;
                    Plotly.relayout('chart-container', { 'scene.camera': newCamera });
                });

                graphDiv.addEventListener('touchstart', stopRotation);
                graphDiv.addEventListener('wheel', stopRotation);

                requestAnimationFrame(animateGlobe);

            } catch (err) {
                console.error("Critical Error:", err);
                document.getElementById('loading').innerText = "Error initializing app.";
            }
        }

        async function fetchDataAndPlot(isInitial = false) {
            const loading = document.getElementById('loading');
            loading.style.display = 'block';
            loading.innerText = "Querying USGS...";

            try {
                const start = document.getElementById('start-date').value;
                const end = document.getElementById('end-date').value;
                const minMag = document.getElementById('min-mag-slider').value;
                const maxMag = document.getElementById('max-mag-slider').value;
                const minDepth = document.getElementById('min-depth-filter').value;
                const maxDepth = document.getElementById('max-depth-filter').value;
                const limit = document.getElementById('limit-select').value;

                let url = `${USGS_BASE_URL}&starttime=${start}`;
                if (end) url += `&endtime=${end}`;

                if(parseFloat(minMag) > 0) url += `&minmagnitude=${minMag}`;
                if(parseFloat(maxMag) < 10) url += `&maxmagnitude=${maxMag}`;
                url += `&mindepth=${minDepth}&maxdepth=${maxDepth}`;
                url += `&limit=${limit}`;

                console.log("Fetching: " + url);

                const res = await fetch(url);
                if (!res.ok) throw new Error("API Limit or Network Error");
                const quakeJson = await res.json();

                stats = { maxMag: 0, maxDepth: 0, minTime: Infinity, maxTime: -Infinity, avgMag: 0, minMag: Infinity, minDepth: Infinity };
                let totalMag = 0, count = 0, totalRealMag = 0, totalDepth = 0;

                rawQuakeData = quakeJson.features.map(f => {
                    const realMag = f.properties.mag || 0;
                    const visualMag = Math.max(realMag, 0.1);
                    const depth = f.geometry.coordinates[2];
                    const time = f.properties.time;

                    if (realMag < stats.minMag) stats.minMag = realMag;
                    if (realMag > stats.maxMag) stats.maxMag = realMag;
                    if (depth < stats.minDepth) stats.minDepth = depth;
                    if (depth > stats.maxDepth) stats.maxDepth = depth;
                    if (time < stats.minTime) stats.minTime = time;
                    if (time > stats.maxTime) stats.maxTime = time;

                    totalMag += visualMag;
                    totalRealMag += realMag;
                    totalDepth += depth;
                    count++;

                    return {
                        lat: f.geometry.coordinates[1],
                        lon: f.geometry.coordinates[0],
                        depth: depth,
                        mag: visualMag,
                        realMag: realMag,
                        time: time,
                        place: f.properties.place || "Unknown"
                    };
                });

                if (count === 0) {
                    stats.minMag = 0; stats.maxMag = 0; stats.minDepth = 0; stats.maxDepth = 0;
                    stats.minTime = Date.now(); stats.maxTime = Date.now();
                }

                stats.avgMag = count > 0 ? (totalMag / count) : 0;
                const realAvgMag = count > 0 ? (totalRealMag / count) : 0;
                const avgDepth = count > 0 ? (totalDepth / count) : 0;

                console.log("--- DATA REPORT ---");
                console.log(`Count: ${count}, Avg Mag: ${realAvgMag.toFixed(2)}, Max Mag: ${stats.maxMag.toFixed(2)}`);
                console.log(`Depth: ${stats.minDepth}km - ${stats.maxDepth}km`);

                document.getElementById('info-overlay').innerText = `Data: ${count} earthquakes. Source: USGS.`;

                updatePlot(isInitial);
                loading.style.display = 'none';

            } catch (err) {
                console.error(err);
                loading.innerText = "Error: " + err.message;
            }
        }

        function animateGlobe() {
            const graphDiv = document.getElementById('chart-container');
            const scene = graphDiv._fullLayout ? graphDiv._fullLayout.scene : null;

            if (scene && scene.camera && autoRotate) {
                const cos = Math.cos(ROTATION_SPEED);
                const sin = Math.sin(ROTATION_SPEED);

                // We use our 'Source of Truth' camera to calculate the next step
                const currentEye = currentCamera.eye;

                const newX = currentEye.x * cos - currentEye.y * sin;
                const newY = currentEye.x * sin + currentEye.y * cos;
                const newEye = { x: newX, y: newY, z: currentEye.z };

                // Update Source of Truth
                currentCamera.eye = newEye;

                Plotly.relayout('chart-container', {
                    'scene.camera.eye': newEye
                });
            }
            requestAnimationFrame(animateGlobe);
        }

        function updateLabels() {
            document.getElementById('size-val').innerText = parseFloat(document.getElementById('size-slider').value).toFixed(1);
            document.getElementById('mag-val').innerText = parseFloat(document.getElementById('mag-slider').value).toFixed(2);
            document.getElementById('depth-val').innerText = parseFloat(document.getElementById('depth-slider').value).toFixed(1);

            const bIndex = parseInt(document.getElementById('border-slider').value);
            document.getElementById('border-val').innerText = BORDER_WIDTHS[bIndex];

            const pIndex = parseInt(document.getElementById('plate-width-slider').value);
            document.getElementById('plate-width-val').innerText = BORDER_WIDTHS[pIndex];

            document.getElementById('min-mag-val').innerText = document.getElementById('min-mag-slider').value;
            document.getElementById('max-mag-val').innerText = document.getElementById('max-mag-slider').value;
            document.getElementById('min-depth-filter-val').innerText = document.getElementById('min-depth-filter').value;
            document.getElementById('max-depth-filter-val').innerText = document.getElementById('max-depth-filter').value;
        }

        function calculateResponsiveCamera() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const aspectRatio = width / height;
            const baseDistance = 0.9;
            let finalDistance = (aspectRatio >= 1) ? baseDistance : Math.max(1.5, baseDistance / aspectRatio);

            return {
                eye: { x: finalDistance, y: finalDistance, z: finalDistance * 0.5 },
                center: { x: 0, y: 0, z: 0 },
                up: { x: 0, y: 0, z: 1 }
            };
        }

        function updatePlot(isInitial = false) {
            const baseSize = parseFloat(document.getElementById('size-slider').value);
            const magBonusScale = parseFloat(document.getElementById('mag-slider').value);
            const depthScale = parseFloat(document.getElementById('depth-slider').value);
            const borderWidth = BORDER_WIDTHS[parseInt(document.getElementById('border-slider').value)];
            const plateWidth = BORDER_WIDTHS[parseInt(document.getElementById('plate-width-slider').value)];

            const selectedPalette = document.getElementById('color-select').value;
            const colorMode = document.getElementById('color-mode').value;

            const qx = [], qy = [], qz = [], sizes = [], ghostSizes = [], colors = [], texts = [];

            const MIDPOINT = 1.618;

            for (const q of rawQuakeData) {
                const r_quake = EARTH_RADIUS - (q.depth * depthScale);
                const [x, y, z] = latLonToXYZ(q.lat, q.lon, r_quake);
                qx.push(x); qy.push(y); qz.push(z);

                let sizeFactor = q.mag;
                if (q.mag > MIDPOINT) {
                    const diff = q.mag - MIDPOINT;
                    sizeFactor += (Math.pow(diff, 3) * magBonusScale);
                }
                const s = baseSize * (sizeFactor / 2.5);
                sizes.push(s);
                ghostSizes.push(Math.max(s * 2, 10));

                if (colorMode === 'depth') colors.push(q.depth);
                else if (colorMode === 'mag') colors.push(q.mag);
                else colors.push(q.time);

                const d = new Date(q.time);
                const dateStr = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')} ${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`;
                texts.push(
                    `<b>${q.place}</b><br>` +
                    `Date: ${dateStr}<br>` +
                    `Magnitude: ${q.realMag.toFixed(2)}<br>` +
                    `Depth: ${q.depth.toFixed(2)}km`
                );
            }

            let colorSettings = {
                colorscale: selectedPalette,
                colorbar: { x: 0, len: 0.5, thickness: 15, titlefont: {color: 'white'}, tickfont: {color: 'white'} }
            };

            if (colorMode === 'depth') {
                colorSettings.title = 'Depth (km)';
                colorSettings.cmin = 0;
                colorSettings.cmax = Math.ceil(stats.maxDepth / 100) * 100;
            } else if (colorMode === 'mag') {
                colorSettings.title = 'Magnitude';
                colorSettings.cmin = 0;
                colorSettings.cmax = 9;
            } else {
                colorSettings.title = 'Date';
                colorSettings.cmin = stats.minTime;
                colorSettings.cmax = stats.maxTime;
            }

            const gridTrace = {
                type: 'scatter3d', mode: 'lines',
                x: staticGridArrays.x, y: staticGridArrays.y, z: staticGridArrays.z,
                line: { color: '#333', width: 1 }, opacity: 0.5, hoverinfo: 'skip'
            };

            const borderTrace = {
                type: 'scatter3d', mode: 'lines',
                x: staticBorderArrays.x, y: staticBorderArrays.y, z: staticBorderArrays.z,
                line: { color: '#00ffff', width: borderWidth }, opacity: 0.4, hoverinfo: 'skip',
                visible: borderWidth > 0
            };

            const plateTrace = {
                type: 'scatter3d', mode: 'lines',
                x: staticPlateArrays.x, y: staticPlateArrays.y, z: staticPlateArrays.z,
                line: { color: '#1E90FF', width: plateWidth }, opacity: 0.8, hoverinfo: 'skip',
                visible: plateWidth > 0
            };

            const quakeTrace = {
                type: 'scatter3d', mode: 'markers',
                x: qx, y: qy, z: qz,
                hoverinfo: 'skip',
                marker: {
                    size: sizes, color: colors,
                    colorscale: colorSettings.colorscale, cmin: colorSettings.cmin, cmax: colorSettings.cmax,
                    colorbar: colorSettings.colorbar, opacity: 1.0, line: { width: 0 }
                }
            };

            const ghostTrace = {
                type: 'scatter3d', mode: 'markers',
                x: qx, y: qy, z: qz,
                text: texts, hoverinfo: 'text',
                marker: { size: ghostSizes, color: 'rgba(0,0,0,0)', opacity: 0.0 }
            };

            const layout = {
                paper_bgcolor: 'black', plot_bgcolor: 'black',
                margin: { l: 0, r: 0, t: 0, b: 0 },
                hovermode: 'closest',
                scene: {
                    xaxis: { visible: false, showbackground: false },
                    yaxis: { visible: false, showbackground: false },
                    zaxis: { visible: false, showbackground: false },
                    aspectmode: 'data',
                    dragmode: 'orbit'
                },
                showlegend: false
            };

            // Set camera from our tracked source of truth
            if (isInitial) {
                currentCamera = calculateResponsiveCamera();
            }
            layout.scene.camera = currentCamera;

            // uirevision is NOT used because we are manually supplying the exact camera state
            // that we have been tracking via events.

            Plotly.react('chart-container', [gridTrace, borderTrace, plateTrace, quakeTrace, ghostTrace], layout, {responsive: true});
        }

        initApp();
    </script>
</body>
</html>